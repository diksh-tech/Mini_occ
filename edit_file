# ag_ui_adapter.py
import os
import json
import asyncio
import time
import uuid
from typing import AsyncGenerator, List
from fastapi import FastAPI, Request, HTTPException
from fastapi.responses import StreamingResponse
from fastapi.middleware.cors import CORSMiddleware
from client import FlightOpsMCPClient

app = FastAPI(title="FlightOps ‚Äî AG-UI Adapter")

# CORS (adjust origins for your Vite origin)
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],           # lock down in prod
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

mcp_client = FlightOpsMCPClient()

def sse_event(data: dict) -> str:
    """Encode one SSE event (JSON payload)"""
    return f"data: {json.dumps(data, default=str, ensure_ascii=False)}\n\n"

async def ensure_mcp_connected():
    if not mcp_client.session:
        await mcp_client.connect()

@app.on_event("startup")
async def startup_event():
    try:
        await ensure_mcp_connected()
    except Exception:
        # don't crash; /health will reflect status
        pass

@app.get("/")
async def root():
    return {"message": "FlightOps AG-UI Adapter running", "status": "ok"}

@app.get("/health")
async def health():
    try:
        await ensure_mcp_connected()
        return {"status": "healthy", "mcp_connected": True}
    except Exception as e:
        return {"status": "unhealthy", "mcp_connected": False, "error": str(e)}

def chunk_text(txt: str, max_len: int = 200) -> List[str]:
    """
    Split text into small chunks for streaming as typing.
    Prefer sentence boundaries; fallback by length.
    """
    txt = txt or ""
    parts: List[str] = []
    buf = ""

    def flush():
        nonlocal buf
        if buf:
            parts.append(buf)
            buf = ""

    for ch in txt:
        buf += ch
        # flush at sentence end or when too long
        if ch in ".!?\n" and len(buf) >= max_len // 2:
            flush()
        elif len(buf) >= max_len:
            flush()
    flush()
    return parts

@app.post("/agent", response_class=StreamingResponse)
async def run_agent(request: Request):
    """
    AG-UI compatible streaming endpoint (SSE).
    Expected body:
      {
        thread_id?, run_id?,
        messages: [{role, content}, ...],
        tools?: []
      }
    """
    try:
        body = await request.json()
    except Exception:
        raise HTTPException(status_code=400, detail="Invalid JSON body")

    thread_id = body.get("thread_id") or f"thread-{uuid.uuid4().hex[:8]}"
    run_id = body.get("run_id") or f"run-{uuid.uuid4().hex[:8]}"
    messages = body.get("messages", [])

    # last user message as query
    user_query = ""
    if messages:
        last = messages[-1]
        if isinstance(last, dict) and last.get("role") == "user":
            user_query = last.get("content", "") or ""
        elif isinstance(last, str):
            user_query = last

    if not user_query.strip():
        raise HTTPException(status_code=400, detail="No user query found")

    async def event_stream() -> AsyncGenerator[str, None]:
        last_heartbeat = time.time()

        # --- RUN STARTED
        yield sse_event({"type": "RUN_STARTED", "thread_id": thread_id, "run_id": run_id})
        
        # THINKING: Initial analysis
        yield sse_event({
            "type": "STATE_UPDATE", 
            "state": {
                "phase": "thinking", 
                "progress_pct": 5,
                "message": "üß† Analyzing your flight query..."
            }
        })

        # ensure MCP
        try:
            await ensure_mcp_connected()
        except Exception as e:
            yield sse_event({"type": "RUN_ERROR", "error": f"MCP connect failed: {e}"})
            return

        loop = asyncio.get_event_loop()

        # --- PLAN (THINKING phase)
        yield sse_event({
            "type": "STATE_UPDATE", 
            "state": {
                "phase": "thinking", 
                "progress_pct": 15,
                "message": "üìã Planning which flight data tools to use..."
            }
        })
        
        try:
            plan_data = await loop.run_in_executor(None, mcp_client.plan_tools, user_query)
        except Exception as e:
            yield sse_event({"type": "RUN_ERROR", "error": f"Planner error: {e}"})
            return

        plan = plan_data.get("plan", []) if isinstance(plan_data, dict) else []
        planning_usage = plan_data.get("llm_usage", {})
        yield sse_event({"type": "STATE_SNAPSHOT", "snapshot": {"plan": plan}})

        if not plan:
            yield sse_event({
                "type": "TEXT_MESSAGE_CONTENT", 
                "message": {
                    "id": f"msg-{uuid.uuid4().hex[:8]}",
                    "role": "assistant",
                    "content": "I couldn't generate a valid plan for your query. Please try rephrasing."
                }
            })
            yield sse_event({"type": "STATE_UPDATE", "state": {"phase": "finished", "progress_pct": 100}})
            yield sse_event({"type": "RUN_FINISHED", "run_id": run_id})
            return

        # --- PROCESSING: Tool execution
        yield sse_event({
            "type": "STATE_UPDATE", 
            "state": {
                "phase": "processing", 
                "progress_pct": 20,
                "message": f"üõ†Ô∏è Executing {len(plan)} flight data tools..."
            }
        })

        results = []
        num_steps = max(1, len(plan))
        per_step = 60.0 / num_steps  # 20% to 80%
        current_progress = 20.0

        for step_index, step in enumerate(plan):
            if await request.is_disconnected():
                return

            tool_name = step.get("tool")
            args = step.get("arguments", {}) or {}

            # Update processing status for current tool
            yield sse_event({
                "type": "STATE_UPDATE", 
                "state": {
                    "phase": "processing",
                    "progress_pct": round(current_progress),
                    "message": f"üîß Running {tool_name}..."
                }
            })

            tool_call_id = f"toolcall-{uuid.uuid4().hex[:8]}"
            
            # Tool call events
            yield sse_event({
                "type": "TOOL_CALL_START",
                "toolCallId": tool_call_id,
                "toolCallName": tool_name,
                "parentMessageId": None
            })

            yield sse_event({
                "type": "TOOL_CALL_ARGS",
                "toolCallId": tool_call_id,
                "delta": json.dumps(args, ensure_ascii=False)
            })
            yield sse_event({"type": "TOOL_CALL_END", "toolCallId": tool_call_id})

            # call tool
            try:
                tool_result = await mcp_client.invoke_tool(tool_name, args)
            except Exception as exc:
                tool_result = {"error": str(exc)}

            # result
            yield sse_event({
                "type": "TOOL_CALL_RESULT",
                "message": {
                    "id": f"msg-{uuid.uuid4().hex[:8]}",
                    "role": "tool",
                    "content": json.dumps(tool_result, ensure_ascii=False),
                    "tool_call_id": tool_call_id,
                }
            })
            results.append({tool_name: tool_result})

            yield sse_event({
                "type": "STEP_FINISHED",
                "step_index": step_index,
                "tool": tool_name
            })

            # update progress
            current_progress = min(80.0, 20.0 + per_step * (step_index + 1))
            
            # heartbeat every ~15s while long tools run
            if time.time() - last_heartbeat > 15:
                yield sse_event({"type": "HEARTBEAT", "ts": time.time()})
                last_heartbeat = time.time()

        # --- TYPING: Result generation
        yield sse_event({
            "type": "STATE_UPDATE", 
            "state": {
                "phase": "typing", 
                "progress_pct": 85,
                "message": "‚úçÔ∏è Generating your flight analysis..."
            }
        })

        try:
            summary_obj = await loop.run_in_executor(None, mcp_client.summarize_results, user_query, plan, results)
            assistant_text = summary_obj.get("summary", "") if isinstance(summary_obj, dict) else str(summary_obj)
            summarization_usage = summary_obj.get("llm_usage", {})
        except Exception as e:
            assistant_text = f"‚ùå Failed to summarize results: {e}"
            summarization_usage = {}

        # Calculate total tokens and append to assistant text
        total_tokens = (planning_usage.get('total_tokens', 0) + 
                       summarization_usage.get('total_tokens', 0))
        if total_tokens > 0:
            assistant_text += f"\n\nüìä Token Usage: {total_tokens} tokens (Planning: {planning_usage.get('total_tokens', 0)}, Summarization: {summarization_usage.get('total_tokens', 0)})"

        # Stream summary as chunks (typing effect)
        msg_id = f"msg-{uuid.uuid4().hex[:8]}"
        
        # Start the message
        yield sse_event({
            "type": "TEXT_MESSAGE_CONTENT",
            "message": {
                "id": msg_id,
                "role": "assistant",
                "content": ""  # Start with empty content
            }
        })

        # Stream chunks with typing effect
        chunks = chunk_text(assistant_text, max_len=150)
        for i, chunk in enumerate(chunks):
            yield sse_event({
                "type": "TEXT_MESSAGE_CONTENT",
                "message": {
                    "id": msg_id,
                    "role": "assistant", 
                    "delta": chunk  # AG-UI delta for streaming
                }
            })
            
            # Update typing progress
            typing_progress = 85 + (i / len(chunks)) * 15
            yield sse_event({
                "type": "STATE_UPDATE",
                "state": {
                    "phase": "typing",
                    "progress_pct": round(typing_progress),
                    "message": "‚úçÔ∏è Generating your flight analysis..."
                }
            })
            
            await asyncio.sleep(0.03)  # Typing speed

        # Final state
        yield sse_event({"type": "STATE_SNAPSHOT", "snapshot": {"plan": plan, "results": results}})
        yield sse_event({
            "type": "STATE_UPDATE", 
            "state": {
                "phase": "finished", 
                "progress_pct": 100,
                "message": "‚úÖ Analysis complete"
            }
        })
        yield sse_event({"type": "RUN_FINISHED", "run_id": run_id})

    return StreamingResponse(event_stream(), media_type="text/event-stream")
####################################333
/* Status Indicator - Left Aligned */
.status-indicator {
  align-self: flex-start;
  margin-left: 0;
}

/* System Messages - Left Aligned */
.system-message {
  text-align: left;
  justify-content: flex-start;
}

.system-content {
  margin-left: 0;
  text-align: left;
}

/* Make Input Boxes Smaller */
.input-container {
  padding: 10px 16px;
}

.message-input {
  padding: 6px 12px;
  font-size: 14px;
  height: 34px;
}

.send-button {
  padding: 6px 14px;
  font-size: 14px;
  height: 34px;
  min-width: 55px;
}
##############################

/* Status Indicator - Left Aligned */
.status-indicator {
  align-self: flex-start; /* This makes it left-aligned */
  margin-left: 0;
}

/* System Messages - Left Aligned */
.system-message {
  text-align: left;
  justify-content: flex-start;
}

.system-content {
  margin-left: 0;
  text-align: left;
}

/* Make Input Boxes Smaller */
.input-container {
  padding: 10px 16px; /* Reduced padding */
}

.message-input {
  padding: 6px 12px; /* Smaller padding */
  font-size: 14px; /* Slightly smaller font */
  height: 34px; /* Fixed height */
}

.send-button {
  padding: 6px 14px; /* Smaller padding */
  font-size: 14px; /* Slightly smaller font */
  height: 34px; /* Fixed height */
  min-width: 55px; /* Minimum width */
}
#########################################
# --- TYPING: Result generation
yield sse_event({
    "type": "STATE_UPDATE", 
    "state": {
        "phase": "typing", 
        "progress_pct": 85,
        "message": "‚úçÔ∏è Generating your flight analysis..."
    }
})

try:
    summary_obj = await loop.run_in_executor(None, mcp_client.summarize_results, user_query, plan, results)
    assistant_text = summary_obj.get("summary", "") if isinstance(summary_obj, dict) else str(summary_obj)
    summarization_usage = summary_obj.get("llm_usage", {})
except Exception as e:
    assistant_text = f"‚ùå Failed to summarize results: {e}"
    summarization_usage = {}

# Calculate total tokens and append to assistant text
total_tokens = (planning_usage.get('total_tokens', 0) + 
               summarization_usage.get('total_tokens', 0))
if total_tokens > 0:
    assistant_text += f"\n\nüìä Token Usage: {total_tokens} tokens (Planning: {planning_usage.get('total_tokens', 0)}, Summarization: {summarization_usage.get('total_tokens', 0)})"

# Stream summary as chunks (typing effect)
msg_id = f"msg-{uuid.uuid4().hex[:8]}"
##################################
import React from "react";

export default function MessageBubble({ role, content, timestamp, isSystem }) {
  // Format content with proper line breaks and clean spacing
  const formatContent = (text) => {
    if (!text) return text;
    
    return text.split('\n').map((line, index) => {
      const trimmedLine = line.trim();
      if (!trimmedLine) return <br key={index} />;
      
      // Check if the line contains token usage info
      const isTokenUsage = trimmedLine.includes('üìä Token Usage:');
      const className = isTokenUsage ? 'token-usage-line' : 'message-line';
      
      return (
        <div key={index} className={className}>
          {trimmedLine}
        </div>
      );
    });
  };

  if (isSystem) {
    return (
      <div className="system-message">
        <div className="system-content">
          <div className="system-text">{formatContent(content)}</div>
          <div className="system-timestamp">{timestamp}</div>
        </div>
      </div>
    );
  }

  return (
    <div className={`message ${role}-message`}>
      <div className="message-content">
        <div className="message-text">{formatContent(content)}</div>
        <div className="message-timestamp">{timestamp}</div>
      </div>
    </div>
  );
}
################################################

/* Messages Container */
.messages-container {
  flex: 1;
  overflow-y: auto;
  padding: 16px; /* Reduced padding */
  display: flex;
  flex-direction: column;
  gap: 12px; /* Reduced gap */
}

/* Message Bubbles */
.message {
  display: flex;
  max-width: 85%; /* Slightly smaller max width */
}

.user-message {
  align-self: flex-end;
}

.assistant-message {
  align-self: flex-start;
}

.message-content {
  padding: 10px 14px; /* Smaller padding */
  border-radius: 16px; /* Slightly smaller radius */
  box-shadow: 0 1px 4px rgba(0,0,0,0.1); /* Lighter shadow */
}

.user-message .message-content {
  background: #007bff;
  color: white;
  border-bottom-right-radius: 6px;
}

.assistant-message .message-content {
  background: #f8f9fa;
  border: 1px solid #e9ecef;
  border-bottom-left-radius: 6px;
}

/* Message Text Formatting */
.message-text {
  line-height: 1.4; /* Tighter line height */
  white-space: pre-wrap;
  font-size: 14px; /* Slightly smaller font */
}

.message-line {
  margin: 3px 0; /* Tighter spacing */
  line-height: 1.4;
  color: #333;
}

.token-usage-line {
  margin: 8px 0 0 0;
  padding-top: 8px;
  border-top: 1px dashed #ddd;
  font-size: 12px;
  color: #666;
  font-style: italic;
}

.message-timestamp {
  font-size: 11px; /* Smaller timestamp */
  color: #6c757d;
  text-align: right;
  margin-top: 6px;
}

/* System Messages */
.system-message {
  display: flex;
  justify-content: center;
  margin: 6px 0; /* Reduced margin */
}

.system-content {
  background: #e3f2fd;
  border-radius: 14px; /* Smaller radius */
  padding: 6px 12px; /* Smaller padding */
  font-size: 12px; /* Smaller font */
  color: #1976d2;
  max-width: 70%;
}

.system-text {
  font-weight: 500;
  text-align: center;
}

.system-timestamp {
  font-size: 10px; /* Smaller timestamp */
  color: #5c6bc0;
  text-align: center;
  margin-top: 2px;
}

/* Status Indicator - Left Aligned */
.status-indicator {
  background: white;
  border: 1px solid #e0e0e0;
  border-radius: 8px;
  padding: 10px 12px; /* Smaller padding */
  margin: 6px 0;
  box-shadow: 0 1px 3px rgba(0,0,0,0.1);
  align-self: flex-start; /* Left aligned */
  max-width: 85%; /* Match message width */
}

.status-content {
  display: flex;
  align-items: center;
  gap: 10px; /* Reduced gap */
}

.status-icon {
  font-size: 1.1em; /* Slightly smaller */
}

.status-message {
  flex: 1;
  font-weight: 500;
  color: #333;
  font-size: 13px; /* Smaller font */
}

.progress-bar {
  width: 80px; /* Smaller progress bar */
  height: 5px; /* Thinner */
  background: #f0f0f0;
  border-radius: 3px;
  overflow: hidden;
}

.progress-fill {
  height: 100%;
  background: linear-gradient(90deg, #4CAF50, #8BC34A);
  transition: width 0.3s ease;
}

/* Loading Animation */
.loading-message {
  align-self: flex-start;
  max-width: 85%;
}

.loading-dots {
  display: flex;
  gap: 4px;
  padding: 12px 16px; /* Smaller padding */
  background: #f8f9fa;
  border-radius: 16px;
  border-bottom-left-radius: 6px;
}

.loading-dots span {
  width: 6px; /* Smaller dots */
  height: 6px;
  border-radius: 50%;
  background: #ccc;
  animation: bounce 1.4s infinite ease-in-out both;
}

.loading-dots span:nth-child(1) { animation-delay: -0.32s; }
.loading-dots span:nth-child(2) { animation-delay: -0.16s; }

.loading-timestamp {
  font-size: 11px;
  color: #6c757d;
  text-align: left;
  margin-top: 4px;
  padding-left: 16px;
}

@keyframes bounce {
  0%, 80%, 100% { transform: scale(0); }
  40% { transform: scale(1); }
}

/* Input Container - Smaller */
.input-container {
  display: flex;
  gap: 8px;
  padding: 12px 16px;
  background: white;
  border-top: 1px solid #e0e0e0;
}

.message-input {
  flex: 1;
  padding: 8px 12px;
  border: 1px solid #ddd;
  border-radius: 20px;
  font-size: 13px;
  outline: none;
  transition: border-color 0.2s;
  height: 36px;
}

.message-input:focus {
  border-color: #007bff;
}

.send-button {
  padding: 8px 16px;
  background: #007bff;
  color: white;
  border: none;
  border-radius: 20px;
  cursor: pointer;
  font-size: 13px;
  transition: background-color 0.2s;
  height: 36px;
  min-width: 60px;
}

.send-button:hover:not(:disabled) {
  background: #0056b3;
}

.send-button:disabled {
  background: #ccc;
  cursor: not-allowed;
}
#############################################################
SYSTEM_PROMPT_SUMMARIZE = """
You are an assistant that summarizes tool outputs into a concise, readable answer about flight operations.
"" 
# ag_ui_adapter.py
import os
import json
import asyncio
import time
import uuid
from typing import AsyncGenerator, List
from fastapi import FastAPI, Request, HTTPException
from fastapi.responses import StreamingResponse
from fastapi.middleware.cors import CORSMiddleware
from client import FlightOpsMCPClient

app = FastAPI(title="FlightOps ‚Äî AG-UI Adapter")

# CORS (adjust origins for your Vite origin)
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],           # lock down in prod
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

mcp_client = FlightOpsMCPClient()

def sse_event(data: dict) -> str:
    """Encode one SSE event (JSON payload)"""
    return f"data: {json.dumps(data, default=str, ensure_ascii=False)}\n\n"

async def ensure_mcp_connected():
    if not mcp_client.session:
        await mcp_client.connect()

@app.on_event("startup")
async def startup_event():
    try:
        await ensure_mcp_connected()
    except Exception:
        # don't crash; /health will reflect status
        pass

@app.get("/")
async def root():
    return {"message": "FlightOps AG-UI Adapter running", "status": "ok"}

@app.get("/health")
async def health():
    try:
        await ensure_mcp_connected()
        return {"status": "healthy", "mcp_connected": True}
    except Exception as e:
        return {"status": "unhealthy", "mcp_connected": False, "error": str(e)}

def chunk_text(txt: str, max_len: int = 200) -> List[str]:
    """
    Split text into small chunks for streaming as typing.
    Prefer sentence boundaries; fallback by length.
    """
    txt = txt or ""
    parts: List[str] = []
    buf = ""

    def flush():
        nonlocal buf
        if buf:
            parts.append(buf)
            buf = ""

    for ch in txt:
        buf += ch
        # flush at sentence end or when too long
        if ch in ".!?\n" and len(buf) >= max_len // 2:
            flush()
        elif len(buf) >= max_len:
            flush()
    flush()
    return parts

@app.post("/agent", response_class=StreamingResponse)
async def run_agent(request: Request):
    """
    AG-UI compatible streaming endpoint (SSE).
    Expected body:
      {
        thread_id?, run_id?,
        messages: [{role, content}, ...],
        tools?: []
      }
    """
    try:
        body = await request.json()
    except Exception:
        raise HTTPException(status_code=400, detail="Invalid JSON body")

    thread_id = body.get("thread_id") or f"thread-{uuid.uuid4().hex[:8]}"
    run_id = body.get("run_id") or f"run-{uuid.uuid4().hex[:8]}"
    messages = body.get("messages", [])

    # last user message as query
    user_query = ""
    if messages:
        last = messages[-1]
        if isinstance(last, dict) and last.get("role") == "user":
            user_query = last.get("content", "") or ""
        elif isinstance(last, str):
            user_query = last

    if not user_query.strip():
        raise HTTPException(status_code=400, detail="No user query found")

    async def event_stream() -> AsyncGenerator[str, None]:
        last_heartbeat = time.time()

        # --- RUN STARTED
        yield sse_event({"type": "RUN_STARTED", "thread_id": thread_id, "run_id": run_id})
        
        # THINKING: Initial analysis
        yield sse_event({
            "type": "STATE_UPDATE", 
            "state": {
                "phase": "thinking", 
                "progress_pct": 5,
                "message": "üß† Analyzing your flight query..."
            }
        })

        # ensure MCP
        try:
            await ensure_mcp_connected()
        except Exception as e:
            yield sse_event({"type": "RUN_ERROR", "error": f"MCP connect failed: {e}"})
            return

        loop = asyncio.get_event_loop()

        # --- PLAN (THINKING phase)
        yield sse_event({
            "type": "STATE_UPDATE", 
            "state": {
                "phase": "thinking", 
                "progress_pct": 15,
                "message": "üìã Planning which flight data tools to use..."
            }
        })
        
        try:
            plan_data = await loop.run_in_executor(None, mcp_client.plan_tools, user_query)
        except Exception as e:
            yield sse_event({"type": "RUN_ERROR", "error": f"Planner error: {e}"})
            return

        plan = plan_data.get("plan", []) if isinstance(plan_data, dict) else []
        planning_usage = plan_data.get("llm_usage", {})
        yield sse_event({"type": "STATE_SNAPSHOT", "snapshot": {"plan": plan}})

        if not plan:
            yield sse_event({
                "type": "TEXT_MESSAGE_CONTENT", 
                "message": {
                    "id": f"msg-{uuid.uuid4().hex[:8]}",
                    "role": "assistant",
                    "content": "I couldn't generate a valid plan for your query. Please try rephrasing."
                }
            })
            yield sse_event({"type": "STATE_UPDATE", "state": {"phase": "finished", "progress_pct": 100}})
            yield sse_event({"type": "RUN_FINISHED", "run_id": run_id})
            return

        # --- PROCESSING: Tool execution
        yield sse_event({
            "type": "STATE_UPDATE", 
            "state": {
                "phase": "processing", 
                "progress_pct": 20,
                "message": f"üõ†Ô∏è Executing {len(plan)} flight data tools..."
            }
        })

        results = []
        num_steps = max(1, len(plan))
        per_step = 60.0 / num_steps  # 20% to 80%
        current_progress = 20.0

        for step_index, step in enumerate(plan):
            if await request.is_disconnected():
                return

            tool_name = step.get("tool")
            args = step.get("arguments", {}) or {}

            # Update processing status for current tool
            yield sse_event({
                "type": "STATE_UPDATE", 
                "state": {
                    "phase": "processing",
                    "progress_pct": round(current_progress),
                    "message": f"üîß Running {tool_name}..."
                }
            })

            tool_call_id = f"toolcall-{uuid.uuid4().hex[:8]}"
            
            # Tool call events
            yield sse_event({
                "type": "TOOL_CALL_START",
                "toolCallId": tool_call_id,
                "toolCallName": tool_name,
                "parentMessageId": None
            })

            yield sse_event({
                "type": "TOOL_CALL_ARGS",
                "toolCallId": tool_call_id,
                "delta": json.dumps(args, ensure_ascii=False)
            })
            yield sse_event({"type": "TOOL_CALL_END", "toolCallId": tool_call_id})

            # call tool
            try:
                tool_result = await mcp_client.invoke_tool(tool_name, args)
            except Exception as exc:
                tool_result = {"error": str(exc)}

            # result
            yield sse_event({
                "type": "TOOL_CALL_RESULT",
                "message": {
                    "id": f"msg-{uuid.uuid4().hex[:8]}",
                    "role": "tool",
                    "content": json.dumps(tool_result, ensure_ascii=False),
                    "tool_call_id": tool_call_id,
                }
            })
            results.append({tool_name: tool_result})

            yield sse_event({
                "type": "STEP_FINISHED",
                "step_index": step_index,
                "tool": tool_name
            })

            # update progress
            current_progress = min(80.0, 20.0 + per_step * (step_index + 1))
            
            # heartbeat every ~15s while long tools run
            if time.time() - last_heartbeat > 15:
                yield sse_event({"type": "HEARTBEAT", "ts": time.time()})
                last_heartbeat = time.time()

        # --- TYPING: Result generation
        yield sse_event({
            "type": "STATE_UPDATE", 
            "state": {
                "phase": "typing", 
                "progress_pct": 85,
                "message": "‚úçÔ∏è Generating your flight analysis..."
            }
        })

        try:
            summary_obj = await loop.run_in_executor(None, mcp_client.summarize_results, user_query, plan, results)
            assistant_text = summary_obj.get("summary", "") if isinstance(summary_obj, dict) else str(summary_obj)
            summarization_usage = summary_obj.get("llm_usage", {})
        except Exception as e:
            assistant_text = f"‚ùå Failed to summarize results: {e}"
            summarization_usage = {}

        # Stream summary as chunks (typing effect)
        msg_id = f"msg-{uuid.uuid4().hex[:8]}"
        
        # Start the message
        yield sse_event({
            "type": "TEXT_MESSAGE_CONTENT",
            "message": {
                "id": msg_id,
                "role": "assistant",
                "content": ""  # Start with empty content
            }
        })

        # Stream chunks with typing effect
        chunks = chunk_text(assistant_text, max_len=150)
        for i, chunk in enumerate(chunks):
            yield sse_event({
                "type": "TEXT_MESSAGE_CONTENT",
                "message": {
                    "id": msg_id,
                    "role": "assistant", 
                    "delta": chunk  # AG-UI delta for streaming
                }
            })
            
            # Update typing progress
            typing_progress = 85 + (i / len(chunks)) * 15
            yield sse_event({
                "type": "STATE_UPDATE",
                "state": {
                    "phase": "typing",
                    "progress_pct": round(typing_progress),
                    "message": "‚úçÔ∏è Generating your flight analysis..."
                }
            })
            
            await asyncio.sleep(0.03)  # Typing speed

        # Send token usage as a system message
        if planning_usage or summarization_usage:
            token_msg = {
                "type": "TEXT_MESSAGE_CONTENT",
                "message": {
                    "id": f"token-{uuid.uuid4().hex[:8]}",
                    "role": "system",
                    "content": f"üìä Token Usage: Planning: {planning_usage.get('total_tokens', 0)} tokens, Summarization: {summarization_usage.get('total_tokens', 0)} tokens"
                }
            }
            yield sse_event(token_msg)

        # Final state
        yield sse_event({"type": "STATE_SNAPSHOT", "snapshot": {"plan": plan, "results": results}})
        yield sse_event({
            "type": "STATE_UPDATE", 
            "state": {
                "phase": "finished", 
                "progress_pct": 100,
                "message": "‚úÖ Analysis complete"
            }
        })
        yield sse_event({"type": "RUN_FINISHED", "run_id": run_id})

    return StreamingResponse(event_stream(), media_type="text/event-stream")
    ###############################################
    import React, { useState, useRef, useEffect } from "react";
import MessageBubble from "./MessageBubble";

const AG_AGENT_ENDPOINT = import.meta.env.VITE_AGENT_ENDPOINT || "http://localhost:8001/agent";

export default function ChatPage() {
    const [messages, setMessages] = useState([
        {
            role: "assistant",
            content: "Hello! üëã I'm your FlightOps Agent. Ask me anything about flight operations ‚Äî delays, fuel, passengers, aircraft details, etc.",
            timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
        },
    ]);
    const [input, setInput] = useState("");
    const [loading, setLoading] = useState(false);
    const [agentState, setAgentState] = useState({
        phase: 'idle', // 'thinking' | 'processing' | 'typing' | 'finished' | 'idle'
        progress: 0,
        message: ''
    });
    const messagesEndRef = useRef(null);

    const scrollToBottom = () => {
        messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
    };

    useEffect(() => {
        scrollToBottom();
    }, [messages]);

    async function sendMessage() {
        if (!input.trim()) return;

        const userMessage = { 
            role: "user", 
            content: input,
            timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
        };
        setMessages((prev) => [...prev, userMessage]);
        setLoading(true);
        setInput("");
        
        // Reset agent state
        setAgentState({
            phase: 'thinking',
            progress: 0,
            message: 'Starting analysis...'
        });

        const body = {
            thread_id: "thread-" + Date.now(),
            run_id: "run-" + Date.now(),
            messages: [userMessage],
        };

        try {
            const resp = await fetch(AG_AGENT_ENDPOINT, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(body),
            });

            if (!resp.ok) {
                const errTxt = await resp.text();
                throw new Error(errTxt);
            }

            const reader = resp.body.getReader();
            const decoder = new TextDecoder();
            let buf = "";
            let currentMessageId = null;

            while (true) {
                const { done, value } = await reader.read();
                if (done) break;
                buf += decoder.decode(value, { stream: true });

                let idx;
                while ((idx = buf.indexOf("\n\n")) !== -1) {
                    const chunk = buf.slice(0, idx).trim();
                    buf = buf.slice(idx + 2);
                    const lines = chunk.split("\n");

                    for (const line of lines) {
                        if (line.startsWith("data: ")) {
                            const payload = line.slice(6).trim();
                            if (!payload) continue;

                            try {
                                const event = JSON.parse(payload);
                                handleEvent(event, currentMessageId);
                            } catch (err) {
                                console.warn("Bad SSE line:", payload);
                            }
                        }
                    }
                }
            }
        } catch (err) {
            setMessages((prev) => [
                ...prev,
                { 
                    role: "assistant", 
                    content: "‚ö†Ô∏è Error: " + err.message,
                    timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
                },
            ]);
            setAgentState({ phase: 'idle', progress: 0, message: '' });
        } finally {
            setLoading(false);
        }
    }

    function handleEvent(event, currentMessageId) {
        const timestamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        
        switch (event.type) {
            case "STATE_UPDATE":
                setAgentState(event.state);
                break;
                
            case "TEXT_MESSAGE_CONTENT":
                if (event.message) {
                    // Handle streaming text with deltas
                    if (event.message.delta) {
                        setMessages(prev => {
                            const existingIdx = prev.findIndex(m => m.id === event.message.id);
                            if (existingIdx >= 0) {
                                const updated = [...prev];
                                updated[existingIdx].content += event.message.delta;
                                updated[existingIdx].timestamp = timestamp;
                                return updated;
                            } else {
                                return [...prev, {
                                    id: event.message.id,
                                    role: event.message.role,
                                    content: event.message.delta,
                                    timestamp: timestamp
                                }];
                            }
                        });
                    } else if (event.message.content) {
                        // Complete message
                        setMessages(prev => [...prev, {
                            id: event.message.id,
                            role: event.message.role,
                            content: event.message.content,
                            timestamp: timestamp
                        }]);
                    }
                } else if (event.content) {
                    // Legacy format
                    setMessages(prev => [...prev, {
                        role: "assistant",
                        content: event.content,
                        timestamp: timestamp
                    }]);
                }
                break;
                
            case "TOOL_CALL_START":
                setMessages(prev => [...prev, {
                    role: "system",
                    content: `üõ†Ô∏è Starting ${event.toolCallName}...`,
                    timestamp: timestamp,
                    isSystem: true
                }]);
                break;
                
            case "TOOL_CALL_RESULT":
                // Optional: show tool results in UI
                break;
                
            case "RUN_FINISHED":
                setAgentState({ phase: 'idle', progress: 0, message: '' });
                break;
                
            case "RUN_ERROR":
                setMessages(prev => [...prev, {
                    role: "assistant",
                    content: "‚ùå " + event.error,
                    timestamp: timestamp
                }]);
                setAgentState({ phase: 'idle', progress: 0, message: '' });
                break;
                
            default:
                break;
        }
    }

    // Status indicator component
    const StatusIndicator = () => {
        if (agentState.phase === 'idle') return null;
        
        const phaseIcons = {
            thinking: 'üß†',
            processing: 'üõ†Ô∏è', 
            typing: '‚úçÔ∏è',
            finished: '‚úÖ'
        };
        
        return (
            <div className={`status-indicator ${agentState.phase}`}>
                <div className="status-content">
                    <span className="status-icon">{phaseIcons[agentState.phase]}</span>
                    <span className="status-message">{agentState.message}</span>
                    {agentState.progress > 0 && (
                        <div className="progress-bar">
                            <div 
                                className="progress-fill"
                                style={{ width: `${agentState.progress}%` }}
                            ></div>
                        </div>
                    )}
                </div>
            </div>
        );
    };

    return (
        <div className="chat-container">
            <div className="messages-container">
                {messages.map((msg, idx) => (
                    <MessageBubble 
                        key={msg.id || idx} 
                        role={msg.role} 
                        content={msg.content} 
                        timestamp={msg.timestamp}
                        isSystem={msg.isSystem}
                    />
                ))}
                
                <StatusIndicator />
                
                {loading && agentState.phase === 'idle' && (
                    <div className="loading-message">
                        <div className="loading-dots">
                            <span></span>
                            <span></span>
                            <span></span>
                        </div>
                        <div className="loading-timestamp">
                            {new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
                        </div>
                    </div>
                )}
                <div ref={messagesEndRef} />
            </div>

            <div className="input-container">
                <input
                    type="text"
                    className="message-input"
                    placeholder="Ask about a flight, e.g. 'Why was 6E215 delayed on June 23, 2024?'"
                    value={input}
                    onChange={(e) => setInput(e.target.value)}
                    onKeyDown={(e) => e.key === "Enter" && sendMessage()}
                    disabled={loading}
                />
                <button
                    onClick={sendMessage}
                    className="send-button"
                    disabled={loading}
                >
                    Send
                </button>
            </div>
        </div>
    );
}
####################################3
import React from "react";

export default function MessageBubble({ role, content, timestamp, isSystem }) {
  // Format content with proper line breaks and clean spacing
  const formatContent = (text) => {
    if (!text) return text;
    
    // Replace multiple spaces with single spaces and ensure proper line breaks
    return text.split('\n').map((line, index) => (
      <div key={index} className="message-line">
        {line.trim()}
      </div>
    ));
  };

  if (isSystem) {
    return (
      <div className="system-message">
        <div className="system-content">
          <div className="system-text">{formatContent(content)}</div>
          <div className="system-timestamp">{timestamp}</div>
        </div>
      </div>
    );
  }

  return (
    <div className={`message ${role}-message`}>
      <div className="message-content">
        <div className="message-text">{formatContent(content)}</div>
        <div className="message-timestamp">{timestamp}</div>
      </div>
    </div>
  );
}
######################################
/* Clean message formatting */
.message-line {
  margin: 2px 0;
  line-height: 1.4;
}

.assistant-message .message-content {
  background: #f8f9fa;
  border: 1px solid #e9ecef;
  border-radius: 12px;
  padding: 12px 16px;
}

.system-message {
  text-align: center;
  margin: 8px 0;
}

.system-content {
  display: inline-block;
  background: #e3f2fd;
  border-radius: 16px;
  padding: 6px 12px;
  font-size: 0.85em;
  color: #1976d2;
}

.system-text {
  font-weight: 500;
}

/* Status indicator */
.status-indicator {
  background: white;
  border: 1px solid #e0e0e0;
  border-radius: 8px;
  padding: 12px;
  margin: 8px 0;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.status-content {
  display: flex;
  align-items: center;
  gap: 12px;
}

.status-icon {
  font-size: 1.2em;
}

.status-message {
  flex: 1;
  font-weight: 500;
  color: #333;
}

.progress-bar {
  width: 100px;
  height: 6px;
  background: #f0f0f0;
  border-radius: 3px;
  overflow: hidden;
}

.progress-fill {
  height: 100%;
  background: linear-gradient(90deg, #4CAF50, #8BC34A);
  transition: width 0.3s ease;
}

/* Typing animation */
.loading-dots {
  display: flex;
  gap: 4px;
  padding: 8px 0;
}

.loading-dots span {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: #ccc;
  animation: bounce 1.4s infinite ease-in-out both;
}

.loading-dots span:nth-child(1) { animation-delay: -0.32s; }
.loading-dots span:nth-child(2) { animation-delay: -0.16s; }

@keyframes bounce {
  0%, 80%, 100% { transform: scale(0); }
  40% { transform: scale(1); }
}
