import React, { useState, useRef, useEffect } from "react";
import MessageBubble from "./MessageBubble";

const AG_AGENT_ENDPOINT = import.meta.env.VITE_AGENT_ENDPOINT || "http://localhost:8001/agent";

export default function ChatPage() {
    const [messages, setMessages] = useState([
        {
            role: "assistant",
            content: "Hello! üëã I'm your FlightOps Agent. Ask me anything about flight operations ‚Äî delays, fuel, passengers, aircraft details, etc.",
            timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
        },
    ]);
    const [input, setInput] = useState("");
    const [loading, setLoading] = useState(false);
    const [agentState, setAgentState] = useState({
        phase: 'idle',
        progress: 0,
        message: ''
    });
    const [tokenUsage, setTokenUsage] = useState({
        planning: null,
        summarization: null,
        total: null
    });
    const [showRouteHint, setShowRouteHint] = useState(false);
    const messagesEndRef = useRef(null);

    const scrollToBottom = () => {
        messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
    };

    useEffect(() => {
        scrollToBottom();
    }, [messages]);

    // Auto-focus input when route selection is needed
    useEffect(() => {
        const lastMessage = messages[messages.length - 1];
        if (lastMessage && lastMessage.role === "assistant" && 
            lastMessage.content.includes("Multiple Routes Found!")) {
            setShowRouteHint(true);
            // Auto-focus input for better UX
            const inputElement = document.querySelector(".message-input");
            if (inputElement) inputElement.focus();
        } else {
            setShowRouteHint(false);
        }
    }, [messages]);

    async function sendMessage() {
        if (!input.trim()) return;

        const userMessage = { 
            role: "user", 
            content: input,
            timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
        };
        setMessages((prev) => [...prev, userMessage]);
        setLoading(true);
        setInput("");
        
        setAgentState({
            phase: 'thinking',
            progress: 0,
            message: 'Starting analysis...'
        });
        setTokenUsage({
            planning: null,
            summarization: null,
            total: null
        });

        const body = {
            thread_id: "thread-" + Date.now(),
            run_id: "run-" + Date.now(),
            messages: [...messages, userMessage], // Send all messages for context
        };

        try {
            const resp = await fetch(AG_AGENT_ENDPOINT, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(body),
            });

            if (!resp.ok) {
                const errTxt = await resp.text();
                throw new Error(errTxt);
            }

            const reader = resp.body.getReader();
            const decoder = new TextDecoder();
            let buf = "";
            let currentMessageId = null;

            while (true) {
                const { done, value } = await reader.read();
                if (done) break;
                buf += decoder.decode(value, { stream: true });

                let idx;
                while ((idx = buf.indexOf("\n\n")) !== -1) {
                    const chunk = buf.slice(0, idx).trim();
                    buf = buf.slice(idx + 2);
                    const lines = chunk.split("\n");

                    for (const line of lines) {
                        if (line.startsWith("data: ")) {
                            const payload = line.slice(6).trim();
                            if (!payload) continue;

                            try {
                                const event = JSON.parse(payload);
                                console.log("SSE Event:", event.type, event);
                                handleEvent(event, currentMessageId);
                            } catch (err) {
                                console.warn("Bad SSE line:", payload, err);
                            }
                        }
                    }
                }
            }
        } catch (err) {
            console.error("Error in sendMessage:", err);
            setMessages((prev) => [
                ...prev,
                { 
                    role: "assistant", 
                    content: "‚ö†Ô∏è Error: " + err.message,
                    timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
                },
            ]);
            setAgentState({ phase: 'idle', progress: 0, message: '' });
        } finally {
            setLoading(false);
        }
    }

    function handleEvent(event, currentMessageId) {
        const timestamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        
        console.log("Processing event:", event.type);
        
        switch (event.type) {
            case "STATE_UPDATE":
                setAgentState(event.state);
                break;
                
            case "TEXT_MESSAGE_CONTENT":
                if (event.message) {
                    if (event.message.delta) {
                        setMessages(prev => {
                            const existingIdx = prev.findIndex(m => m.id === event.message.id);
                            if (existingIdx >= 0) {
                                const updated = [...prev];
                                updated[existingIdx].content += event.message.delta;
                                updated[existingIdx].timestamp = timestamp;
                                return updated;
                            } else {
                                return [...prev, {
                                    id: event.message.id,
                                    role: event.message.role,
                                    content: event.message.delta,
                                    timestamp: timestamp
                                }];
                            }
                        });
                    } else if (event.message.content) {
                        setMessages(prev => [...prev, {
                            id: event.message.id,
                            role: event.message.role,
                            content: event.message.content,
                            timestamp: timestamp
                        }]);
                    }
                } else if (event.content) {
                    setMessages(prev => [...prev, {
                        role: "assistant",
                        content: event.content,
                        timestamp: timestamp
                    }]);
                }
                break;
                
            case "TOOL_CALL_START":
                setMessages(prev => [...prev, {
                    role: "system",
                    content: `üõ†Ô∏è Starting ${event.toolCallName}...`,
                    timestamp: timestamp
                }]);
                break;
                
            case "TOKEN_USAGE":
                console.log("TOKEN_USAGE event received:", event.phase, event.usage);
                setTokenUsage(prev => ({
                    ...prev,
                    [event.phase]: event.usage
                }));
                
                if (event.phase === 'total' && event.usage) {
                    setMessages(prev => [...prev, {
                        role: "system",
                        content: `üìä Token Usage: ${event.usage.total_tokens || 0} total (${event.usage.prompt_tokens || 0} prompt + ${event.usage.completion_tokens || 0} completion)`,
                        timestamp: timestamp
                    }]);
                }
                break;
                
            case "RUN_FINISHED":
                setAgentState({ phase: 'idle', progress: 0, message: '' });
                break;
                
            case "RUN_ERROR":
                setMessages(prev => [...prev, {
                    role: "assistant",
                    content: "‚ùå " + event.error,
                    timestamp: timestamp
                }]);
                setAgentState({ phase: 'idle', progress: 0, message: '' });
                break;
                
            default:
                console.log('Unhandled event type:', event.type);
                break;
        }
    }

    const StatusIndicator = () => {
        if (agentState.phase === 'idle' && !tokenUsage.total) return null;
        
        const phaseIcons = {
            thinking: 'üß†',
            processing: 'üõ†Ô∏è', 
            typing: '‚úçÔ∏è',
            finished: '‚úÖ',
            idle: '‚úÖ'
        };
        
        return (
            <div className={`status-indicator ${agentState.phase}`}>
                <div className="status-content">
                    <span className="status-icon">{phaseIcons[agentState.phase]}</span>
                    <span className="status-message">{agentState.message}</span>
                    
                    {tokenUsage.total && (
                        <div className="token-usage">
                            <div className="token-breakdown">
                                <span className="token-label">Total Tokens: </span>
                                <span className="token-value">{tokenUsage.total.total_tokens || 0}</span>
                            </div>
                            <div className="token-details">
                                <span>Prompt: {tokenUsage.total.prompt_tokens || 0}</span>
                                <span>Completion: {tokenUsage.total.completion_tokens || 0}</span>
                            </div>
                        </div>
                    )}
                    
                    {agentState.progress > 0 && (
                        <div className="progress-bar">
                            <div 
                                className="progress-fill"
                                style={{ width: `${agentState.progress}%` }}
                            ></div>
                        </div>
                    )}
                </div>
            </div>
        );
    };

    return (
        <div className="chat-container">
            <div className="messages-container">
                {messages.map((msg, idx) => (
                    <MessageBubble 
                        key={msg.id || idx} 
                        role={msg.role} 
                        content={msg.content} 
                        timestamp={msg.timestamp}
                    />
                ))}
                
                <StatusIndicator />
                
                {loading && agentState.phase === 'idle' && (
                    <div className="loading-message">
                        <div className="loading-dots">
                            <span></span>
                            <span></span>
                            <span></span>
                        </div>
                        <div className="loading-timestamp">
                            {new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
                        </div>
                    </div>
                )}
                <div ref={messagesEndRef} />
            </div>

            <div className="input-container">
                {showRouteHint && (
                    <div className="route-selection-hint">
                        üí° Simply type the route number (1, 2, 3, etc.) and press Enter
                    </div>
                )}
                <input
                    type="text"
                    className="message-input"
                    placeholder={
                        showRouteHint 
                            ? "Enter route number (1, 2, 3...)" 
                            : "Ask about a flight, e.g. 'Why was 6E215 delayed on June 23, 2024?'"
                    }
                    value={input}
                    onChange={(e) => setInput(e.target.value)}
                    onKeyDown={(e) => e.key === "Enter" && sendMessage()}
                    disabled={loading}
                />
                <button
                    onClick={sendMessage}
                    className="send-button"
                    disabled={loading}
                >
                    {showRouteHint ? "Select" : "Send"}
                </button>
            </div>
        </div>
    );
}
##################################
/* Route Selection Hint */
.route-selection-hint {
    background: linear-gradient(135deg, #4f46e5, #7c3aed);
    color: white;
    padding: 0.5rem 1rem;
    border-radius: 8px;
    margin-bottom: 0.5rem;
    font-size: 0.85rem;
    text-align: center;
    animation: pulse 2s infinite;
}

@keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.8; }
}

/* Enhanced message styling for route options */
.assistant-message .message-content {
    background: white;
    color: #374151;
    border: 1px solid #e5e7eb;
    border-bottom-left-radius: 4px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
}

/* Route options styling */
.route-option {
    margin: 0.5rem 0;
    padding: 0.75rem;
    background: #f8fafc;
    border-radius: 8px;
    border-left: 3px solid #4f46e5;
}

.route-option strong {
    color: #1e40af;
}

.route-option-details {
    font-size: 0.85rem;
    color: #6b7280;
    margin-top: 0.25rem;
}
########################################
import os
import logging
import json
from typing import Optional, Any, Dict
from datetime import datetime
from motor.motor_asyncio import AsyncIOMotorClient
from dotenv import load_dotenv
load_dotenv() 

from mcp.server.fastmcp import FastMCP

HOST = os.getenv("MCP_HOST", "127.0.0.1")
PORT = int(os.getenv("MCP_PORT", "8000"))
TRANSPORT = os.getenv("MCP_TRANSPORT", "streamable-http")

MONGODB_URL = os.getenv("MONGO_URI")
DATABASE_NAME = os.getenv("MONGO_DB")
COLLECTION_NAME = os.getenv("MONGO_COLLECTION")

logging.basicConfig(level=os.getenv("LOG_LEVEL", "INFO"))
logger = logging.getLogger("flightops.mcp.server")

mcp = FastMCP("FlightOps MCP Server")

_mongo_client: Optional[AsyncIOMotorClient] = None
_db = None
_col = None

async def get_mongodb_client():
    """Initialize and return the global Motor client, DB and collection."""
    global _mongo_client, _db, _col
    if _mongo_client is None:
        logger.info("Connecting to MongoDB: %s", MONGODB_URL)
        _mongo_client = AsyncIOMotorClient(MONGODB_URL)
        _db = _mongo_client[DATABASE_NAME]
        _col = _db[COLLECTION_NAME]
    return _mongo_client, _db, _col

def normalize_flight_number(flight_number: Any) -> Optional[int]:
    """Convert flight_number to int. MongoDB stores it as int."""
    if flight_number is None or flight_number == "":
        return None
    if isinstance(flight_number, int):
        return flight_number
    try:
        return int(str(flight_number).strip())
    except (ValueError, TypeError):
        logger.warning(f"Could not normalize flight_number: {flight_number}")
        return None

def validate_date(date_str: str) -> Optional[str]:
    """
    Validate date_of_origin string. Accepts common formats.
    Returns normalized ISO date string YYYY-MM-DD if valid, else None.
    """
    if not date_str or date_str == "":
        return None
    
    # Handle common date formats
    formats = [
        "%Y-%m-%d",      # 2024-06-23
        "%d-%m-%Y",      # 23-06-2024
        "%Y/%m/%d",      # 2024/06/23
        "%d/%m/%Y",      # 23/06/2024
        "%B %d, %Y",     # June 23, 2024
        "%d %B %Y",      # 23 June 2024
        "%b %d, %Y",     # Jun 23, 2024
        "%d %b %Y"       # 23 Jun 2024
    ]
    
    for fmt in formats:
        try:
            dt = datetime.strptime(date_str, fmt)
            return dt.strftime("%Y-%m-%d")
        except ValueError:
            continue
    
    logger.warning(f"Could not parse date: {date_str}")
    return None

def make_query(carrier: str, flight_number: Optional[int], date_of_origin: str) -> Dict:
    """
    Build MongoDB query matching the actual database schema.
    """
    query = {}
    
    # Add carrier if provided
    if carrier:
        query["flightLegState.carrier"] = carrier
    
    # Add flight number as integer (as stored in DB)
    if flight_number is not None:
        query["flightLegState.flightNumber"] = flight_number
    
    # Add date if provided
    if date_of_origin:
        query["flightLegState.dateOfOrigin"] = date_of_origin
    
    logger.info(f"Built query: {json.dumps(query)}")
    return query

def response_ok(data: Any) -> str:
    """Return JSON string for successful response."""
    return json.dumps({"ok": True, "data": data}, indent=2, default=str)

def response_error(msg: str, code: int = 400) -> str:
    """Return JSON string for error response."""
    return json.dumps({"ok": False, "error": {"message": msg, "code": code}}, indent=2)

async def _fetch_one_async(query: dict, projection: dict) -> str:
    """
    Consistent async DB fetch and error handling.
    Returns JSON string response.
    """
    try:
        _, _, col = await get_mongodb_client()
        logger.info(f"Executing query: {json.dumps(query)}")
        
        result = await col.find_one(query, projection)
        
        if not result:
            logger.warning(f"No document found for query: {json.dumps(query)}")
            return response_error("No matching document found.", code=404)
        
        # Remove _id and _class to keep output clean
        if "_id" in result:
            result.pop("_id")
        if "_class" in result:
            result.pop("_class")
        
        logger.info(f"Query successful")
        return response_ok(result)
    except Exception as exc:
        logger.exception("DB query failed")
        return response_error(f"DB query failed: {str(exc)}", code=500)

# --- MCP Tools ---

@mcp.tool()
async def health_check() -> str:
    """
    Simple health check for orchestrators and clients.
    Attempts a cheap DB ping.
    """
    try:
        _, _, col = await get_mongodb_client()
        doc = await col.find_one({}, {"_id": 1})
        return response_ok({"status": "ok", "db_connected": doc is not None})
    except Exception as e:
        logger.exception("Health check DB ping failed")
        return response_error("DB unreachable", code=503)

@mcp.tool()
async def get_flight_basic_info(carrier: str = "", flight_number: str = "", date_of_origin: str = "") -> str:
    """
    Fetch basic flight information including carrier, flight number, date, stations, times, and status.
    
    Args:
        carrier: Airline carrier code (e.g., "6E", "AI")
        flight_number: Flight number as string (e.g., "215")
        date_of_origin: Date in YYYY-MM-DD format (e.g., "2024-06-23")
    """
    logger.info(f"get_flight_basic_info: carrier={carrier}, flight_number={flight_number}, date={date_of_origin}")
    
    # Normalize inputs
    fn = normalize_flight_number(flight_number) if flight_number else None
    dob = validate_date(date_of_origin) if date_of_origin else None
    
    if date_of_origin and not dob:
        return response_error("Invalid date_of_origin format. Expected YYYY-MM-DD or common date formats", 400)
    
    query = make_query(carrier, fn, dob)
    
    # Project basic flight information
    projection = {
        "flightLegState.carrier": 1,
        "flightLegState.flightNumber": 1,
        "flightLegState.suffix": 1,
        "flightLegState.dateOfOrigin": 1,
        "flightLegState.seqNumber": 1,
        "flightLegState.startStation": 1,
        "flightLegState.endStation": 1,
        "flightLegState.startStationICAO": 1,
        "flightLegState.endStationICAO": 1,
        "flightLegState.scheduledStartTime": 1,
        "flightLegState.scheduledEndTime": 1,
        "flightLegState.flightStatus": 1,
        "flightLegState.operationalStatus": 1,
        "flightLegState.flightType": 1,
        "flightLegState.blockTimeSch": 1,
        "flightLegState.blockTimeActual": 1,
        "flightLegState.flightHoursActual": 1,
        "flightLegState.isOTPFlight": 1,
        "flightLegState.isOTPAchieved": 1,
        "flightLegState.isOTPConsidered": 1,
        "flightLegState.isOTTFlight": 1,
        "flightLegState.isOTTAchievedFlight": 1,
        "flightLegState.turnTimeFlightBeforeActual": 1,
        "flightLegState.turnTimeFlightBeforeSch": 1
    }
    
    return await _fetch_one_async(query, projection)

@mcp.tool()
async def get_operation_times(carrier: str = "", flight_number: str = "", date_of_origin: str = "") -> str:
    """
    Return estimated and actual operation times for a flight including takeoff, landing, block times,StartTimeOffset, EndTimeOffset.
    
    Args:
        carrier: Airline carrier code
        flight_number: Flight number as string
        date_of_origin: Date in YYYY-MM-DD format
    """
    logger.info(f"get_operation_times: carrier={carrier}, flight_number={flight_number}, date={date_of_origin}")
    
    fn = normalize_flight_number(flight_number) if flight_number else None
    dob = validate_date(date_of_origin) if date_of_origin else None
    
    if date_of_origin and not dob:
        return response_error("Invalid date format.", 400)
    
    query = make_query(carrier, fn, dob)
    
    projection = {
        "flightLegState.carrier": 1,
        "flightLegState.flightNumber": 1,
        "flightLegState.dateOfOrigin": 1,
        "flightLegState.startStation": 1,
        "flightLegState.endStation": 1,
        "flightLegState.scheduledStartTime": 1,
        "flightLegState.scheduledEndTime": 1,
        "flightLegState.startTimeOffset": 1,
        "flightLegState.endTimeOffset": 1,
        "flightLegState.operation.estimatedTimes": 1,
        "flightLegState.operation.actualTimes": 1,
        "flightLegState.taxiOutTime": 1,
        "flightLegState.taxiInTime": 1,
        "flightLegState.blockTimeSch": 1,
        "flightLegState.blockTimeActual": 1,
        "flightLegState.flightHoursActual": 1,
    }
    
    return await _fetch_one_async(query, projection)

@mcp.tool()
async def get_equipment_info(carrier: str = "", flight_number: str = "", date_of_origin: str = "") -> str:
    """
    Get aircraft equipment details including aircraft type, registration (tail number), and configuration.
    
    Args:
        carrier: Airline carrier code
        flight_number: Flight number as string
        date_of_origin: Date in YYYY-MM-DD format
    """
    logger.info(f"get_equipment_info: carrier={carrier}, flight_number={flight_number}, date={date_of_origin}")
    
    fn = normalize_flight_number(flight_number) if flight_number else None
    dob = validate_date(date_of_origin) if date_of_origin else None
    
    query = make_query(carrier, fn, dob)
    
    projection = {
        "flightLegState.carrier": 1,
        "flightLegState.flightNumber": 1,
        "flightLegState.dateOfOrigin": 1,
        "flightLegState.equipment.plannedAircraftType": 1,
        "flightLegState.equipment.aircraft": 1,
        "flightLegState.equipment.aircraftConfiguration": 1,
        "flightLegState.equipment.aircraftRegistration": 1,
        "flightLegState.equipment.assignedAircraftTypeIATA": 1,
        "flightLegState.equipment.assignedAircraftTypeICAO": 1,
        "flightLegState.equipment.assignedAircraftTypeIndigo": 1,
        "flightLegState.equipment.assignedAircraftConfiguration": 1,
        "flightLegState.equipment.tailLock": 1,
        "flightLegState.equipment.onwardFlight": 1,
        "flightLegState.equipment.actualOnwardFlight": 1
    }
    
    return await _fetch_one_async(query, projection)

@mcp.tool()
async def get_delay_summary(carrier: str = "", flight_number: str = "", date_of_origin: str = "", selected_route: str = "") -> str:
    """
    Summarize delay reasons, durations, and total delay time for a specific flight.
    If multiple routes exist, returns route options for user selection.
    
    Args:
        carrier: Airline carrier code (e.g., "6E", "AI")
        flight_number: Flight number as string (e.g., "215")
        date_of_origin: Date in YYYY-MM-DD format (e.g., "2024-06-23")
        selected_route: Route in format "START_STATION-END_STATION" (optional, for when user selects from multiple options)
    """
    logger.info(f"get_delay_summary: carrier={carrier}, flight_number={flight_number}, date={date_of_origin}, selected_route={selected_route}")
    
    # Normalize inputs
    fn = normalize_flight_number(flight_number) if flight_number else None
    dob = validate_date(date_of_origin) if date_of_origin else None
    
    if date_of_origin and not dob:
        return response_error("Invalid date_of_origin format. Expected YYYY-MM-DD or common date formats", 400)
    
    # Step 1: Build base query
    base_query = make_query(carrier, fn, dob)
    
    try:
        _, _, col = await get_mongodb_client()
        
        # Step 2: Count documents for this flight
        count = await col.count_documents(base_query)
        logger.info(f"Found {count} documents for query: {json.dumps(base_query)}")
        
        # Step 3: If multiple documents and no route selected, return route options ONLY
        if count > 1 and not selected_route:
            # Get minimal route information for selection
            cursor = col.find(base_query, {
                "flightLegState.startStation": 1,
                "flightLegState.endStation": 1,
                "flightLegState.scheduledStartTime": 1,
                "flightLegState.flightStatus": 1,
                "_id": 0
            })
            
            routes = []
            async for doc in cursor:
                route_info = {
                    "route_id": f"{doc.get('flightLegState', {}).get('startStation', '')}-{doc.get('flightLegState', {}).get('endStation', '')}",
                    "startStation": doc.get("flightLegState", {}).get("startStation", "Unknown"),
                    "endStation": doc.get("flightLegState", {}).get("endStation", "Unknown"),
                    "scheduledStartTime": doc.get("flightLegState", {}).get("scheduledStartTime", "Unknown"),
                    "flightStatus": doc.get("flightLegState", {}).get("flightStatus", "Unknown")
                }
                # Only add unique routes
                if not any(r["route_id"] == route_info["route_id"] for r in routes):
                    routes.append(route_info)
            
            return response_ok({
                "status": "route_selection_required",
                "multiple_routes": True,
                "message": f"Found {len(routes)} different routes for flight {carrier}{flight_number} on {date_of_origin}.",
                "available_routes": routes,
                "instruction": "Please select a route by providing the route number (1, 2, 3, etc.)",
                "next_step": "Call this tool again with the selected_route parameter"
            })
        
        # Step 4: If single document or route selected, proceed with actual delay summary
        final_query = base_query.copy()
        if selected_route:
            try:
                start_station, end_station = selected_route.split('-')
                final_query["flightLegState.startStation"] = start_station
                final_query["flightLegState.endStation"] = end_station
                logger.info(f"Query modified with selected route: {start_station} -> {end_station}")
            except ValueError:
                return response_error("Invalid selected_route format. Expected 'START_STATION-END_STATION'", 400)
        
        # Step 5: Fetch the actual delay summary
        projection = {
            "flightLegState.carrier": 1,
            "flightLegState.flightNumber": 1,
            "flightLegState.dateOfOrigin": 1,
            "flightLegState.startStation": 1,
            "flightLegState.endStation": 1,
            "flightLegState.scheduledStartTime": 1,
            "flightLegState.operation.actualTimes.offBlock": 1,
            "flightLegState.delays": 1,
            "flightLegState.flightStatus": 1,
            "flightLegState.operationalStatus": 1,
            "flightLegState.startTimeOffset": 1,
            "flightLegState.endTimeOffset": 1
        }
        
        result = await _fetch_one_async(final_query, projection)
        
        # Add route information to the final result
        if isinstance(result, str):
            try:
                result_dict = json.loads(result)
                if result_dict.get("ok") and result_dict.get("data"):
                    result_dict["data"]["selected_route"] = selected_route if selected_route else "auto_selected"
                    return json.dumps(result_dict, indent=2, default=str)
            except:
                pass
        
        return result
        
    except Exception as e:
        logger.exception("Error in get_delay_summary")
        return response_error(f"Database error: {str(e)}", 500)

@mcp.tool()
async def get_fuel_summary(carrier: str = "", flight_number: str = "", date_of_origin: str = "") -> str:
    """
    Retrieve fuel summary including planned vs actual fuel for takeoff, landing, and total consumption.
    
    Args:
        carrier: Airline carrier code
        flight_number: Flight number as string
        date_of_origin: Date in YYYY-MM-DD format
    """
    logger.info(f"get_fuel_summary: carrier={carrier}, flight_number={flight_number}, date={date_of_origin}")
    
    fn = normalize_flight_number(flight_number) if flight_number else None
    dob = validate_date(date_of_origin) if date_of_origin else None
    
    query = make_query(carrier, fn, dob)
    
    projection = {
        "flightLegState.carrier": 1,
        "flightLegState.flightNumber": 1,
        "flightLegState.dateOfOrigin": 1,
        "flightLegState.startStation": 1,
        "flightLegState.endStation": 1,
        "flightLegState.operation.fuel": 1,
        "flightLegState.operation.flightPlan.offBlockFuel": 1,
        "flightLegState.operation.flightPlan.takeoffFuel": 1,
        "flightLegState.operation.flightPlan.landingFuel": 1,
        "flightLegState.operation.flightPlan.holdFuel": 1
    }
    
    return await _fetch_one_async(query, projection)

@mcp.tool()
async def get_passenger_info(carrier: str = "", flight_number: str = "", date_of_origin: str = "") -> str:
    """
    Get passenger count and connection information for the flight.
    
    Args:
        carrier: Airline carrier code
        flight_number: Flight number as string
        date_of_origin: Date in YYYY-MM-DD format
    """
    logger.info(f"get_passenger_info: carrier={carrier}, flight_number={flight_number}, date={date_of_origin}")
    
    fn = normalize_flight_number(flight_number) if flight_number else None
    dob = validate_date(date_of_origin) if date_of_origin else None
    
    query = make_query(carrier, fn, dob)
    
    projection = {
        "flightLegState.carrier": 1,
        "flightLegState.flightNumber": 1,
        "flightLegState.dateOfOrigin": 1,
        "flightLegState.pax": 1
    }
    
    return await _fetch_one_async(query, projection)

@mcp.tool()
async def get_crew_info(carrier: str = "", flight_number: str = "", date_of_origin: str = "") -> str:
    """
    Get crew connections and details for the flight.
    
    Args:
        carrier: Airline carrier code
        flight_number: Flight number as string
        date_of_origin: Date in YYYY-MM-DD format
    """
    logger.info(f"get_crew_info: carrier={carrier}, flight_number={flight_number}, date={date_of_origin}")
    
    fn = normalize_flight_number(flight_number) if flight_number else None
    dob = validate_date(date_of_origin) if date_of_origin else None
    
    query = make_query(carrier, fn, dob)
    
    projection = {
        "flightLegState.carrier": 1,
        "flightLegState.flightNumber": 1,
        "flightLegState.dateOfOrigin": 1,
        "flightLegState.crewConnections": 1
    }
    
    return await _fetch_one_async(query, projection)

@mcp.tool()
async def raw_mongodb_query(query_json: str, projection: str = "", limit: int = 10) -> str:
    """
    Execute a raw MongoDB query (stringified JSON) with optional projection.

    Supports intelligent LLM-decided projections to reduce payload size based on query intent.

    Args:
        query_json: The MongoDB query (as stringified JSON).
        projection: Optional projection (as stringified JSON) for selecting fields.
        limit: Max number of documents to return (default 10, capped at 50).
    """

    def _safe_json_loads(text: str) -> dict:
        """Safely parse JSON, handling single quotes and formatting errors."""
        try:
            return json.loads(text)
        except json.JSONDecodeError:
            try:
                fixed = text.replace("'", '"')
                return json.loads(fixed)
            except Exception as e:
                raise ValueError(f"Invalid JSON: {e}")

    try:
        _, _, col = await get_mongodb_client()

        # --- Parse Query ---
        try:
            query = _safe_json_loads(query_json)
        except ValueError as e:
            return response_error(f"‚ùå Invalid query_json: {str(e)}", 400)

        # --- Parse Projection (optional) ---
        projection_dict = None
        if projection:
            try:
                projection_dict = _safe_json_loads(projection)
            except ValueError as e:
                return response_error(f"‚ùå Invalid projection JSON: {str(e)}", 400)

        # --- Validate types ---
        if not isinstance(query, dict):
            return response_error("‚ùå query_json must be a JSON object.", 400)
        if projection_dict and not isinstance(projection_dict, dict):
            return response_error("‚ùå projection must be a JSON object.", 400)

        # --- Safety guard ---
        forbidden_ops = ["$where", "$out", "$merge", "$accumulator", "$function"]
        for key in query.keys():
            if key in forbidden_ops or key.startswith("$"):
                return response_error(f"‚ùå Operator '{key}' is not allowed.", 400)

        limit = min(max(1, int(limit)), 50)

        # --- Fallback projection ---
        # If the LLM forgets to include projection, return a minimal safe set.
        if not projection_dict:
            projection_dict = {
                "_id": 0,
                "flightLegState.carrier": 1,
                "flightLegState.flightNumber": 1,
                "flightLegState.dateOfOrigin": 1
            }
            
        logger.info(f"Executing MongoDB query: {query} | projection={projection_dict} | limit={limit}")

        # --- Run query ---
        cursor = col.find(query, projection_dict).sort("flightLegState.dateOfOrigin", -1).limit(limit)
        docs = []
        async for doc in cursor:
            doc.pop("_id", None)
            doc.pop("_class", None)
            docs.append(doc)

        if not docs:
            return response_error("No documents found for the given query.", 404)

        return response_ok({
            "count": len(docs),
            "query": query,
            "projection": projection_dict,
            "documents": docs
        })

    except Exception as exc:
        logger.exception("‚ùå raw_mongodb_query failed")
        return response_error(f"Raw MongoDB query failed: {str(exc)}", 500)

@mcp.tool()
async def run_aggregated_query(
    query_type: str = "",
    carrier: str = "",
    field: str = "",
    start_date: str = "",
    end_date: str = "",
    filter_json: str = ""
) -> str:
    """
    Run statistical or comparative MongoDB aggregation queries.

    Args:
        query_type: "average", "sum", "min", "max", "count".
        carrier: Optional carrier filter.
        field: Field to aggregate, e.g. "flightLegState.pax.passengerCount.count".
        start_date: Optional start date (YYYY-MM-DD).
        end_date: Optional end date (YYYY-MM-DD).
        filter_json: Optional filter query (as JSON string).
    """

    _, _, col = await get_mongodb_client()

    match_stage = {}

    # --- Optional filters ---
    if filter_json:
        try:
            match_stage.update(json.loads(filter_json.replace("'", '"')))
        except Exception as e:
            return response_error(f"Invalid filter_json: {e}", 400)

    if carrier:
        match_stage["flightLegState.carrier"] = carrier
    if start_date and end_date:
        match_stage["flightLegState.dateOfOrigin"] = {"$gte": start_date, "$lte": end_date}

    agg_map = {
        "average": {"$avg": f"${field}"},
        "sum": {"$sum": f"${field}"},
        "min": {"$min": f"${field}"},
        "max": {"$max": f"${field}"},
        "count": {"$sum": 1},
    }

    if query_type not in agg_map:
        return response_error(f"Unsupported query_type '{query_type}'. Use one of: average, sum, min, max, count", 400)

    pipeline = [{"$match": match_stage}, {"$group": {"_id": None, "value": agg_map[query_type]}}]

    try:
        logger.info(f"Running aggregation pipeline: {pipeline}")
        docs = await col.aggregate(pipeline).to_list(length=10)
        return response_ok({"pipeline": pipeline, "results": docs})
    except Exception as e:
        logger.exception("Aggregation query failed")
        return response_error(f"Aggregation failed: {str(e)}", 500)

# --- Run MCP Server ---
if __name__ == "__main__":
    logger.info("Starting FlightOps MCP Server on %s:%s (transport=%s)", HOST, PORT, TRANSPORT)
    logger.info("MongoDB URL: %s, Database: %s, Collection: %s", MONGODB_URL, DATABASE_NAME, COLLECTION_NAME)
    mcp.run(transport="streamable-http")
###############################################################
import os
import json
import asyncio
import time
import uuid
import re
from typing import AsyncGenerator, List
from fastapi import FastAPI, Request, HTTPException
from fastapi.responses import StreamingResponse
from fastapi.middleware.cors import CORSMiddleware
from client import FlightOpsMCPClient

app = FastAPI(title="FlightOps ‚Äî AG-UI Adapter")

# CORS (adjust origins for your Vite origin)
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

mcp_client = FlightOpsMCPClient()

# Global context storage for route selection
route_selection_context = {}
last_thread_with_routes = None  # Track last thread that had routes

def sse_event(data: dict) -> str:
    """Encode one SSE event (JSON payload)"""
    return f"data: {json.dumps(data, default=str, ensure_ascii=False)}\n\n"

async def ensure_mcp_connected():
    if not mcp_client.session:
        await mcp_client.connect()

@app.on_event("startup")
async def startup_event():
    try:
        await ensure_mcp_connected()
    except Exception:
        pass

@app.get("/")
async def root():
    return {"message": "FlightOps AG-UI Adapter running", "status": "ok"}

@app.get("/health")
async def health():
    try:
        await ensure_mcp_connected()
        return {"status": "healthy", "mcp_connected": True}
    except Exception as e:
        return {"status": "unhealthy", "mcp_connected": False, "error": str(e)}

def chunk_text(txt: str, max_len: int = 200) -> List[str]:
    txt = txt or ""
    parts: List[str] = []
    buf = ""

    def flush():
        nonlocal buf
        if buf:
            parts.append(buf)
            buf = ""

    for ch in txt:
        buf += ch
        if ch in ".!?\n" and len(buf) >= max_len // 2:
            flush()
        elif len(buf) >= max_len:
            flush()
    flush()
    return parts

@app.post("/agent", response_class=StreamingResponse)
async def run_agent(request: Request):
    global last_thread_with_routes
    
    try:
        body = await request.json()
    except Exception:
        raise HTTPException(status_code=400, detail="Invalid JSON body")

    thread_id = body.get("thread_id") or f"thread-{uuid.uuid4().hex[:8]}"
    run_id = body.get("run_id") or f"run-{uuid.uuid4().hex[:8]}"
    messages = body.get("messages", [])
    
    # Check if this is a route selection response with fallback logic
    is_route_selection = False
    user_selected_route = None
    original_tool_args = None
    context_thread_id = thread_id  # Default to current thread
    
    # üéØ FALLBACK LOGIC: Use last thread if current not found
    if thread_id not in route_selection_context and last_thread_with_routes in route_selection_context:
        context_thread_id = last_thread_with_routes
    
    if context_thread_id in route_selection_context:
        # This is a follow-up message for route selection
        if messages:
            last_message = messages[-1]
            if isinstance(last_message, dict) and last_message.get("role") == "user":
                user_input = last_message.get("content", "").strip()
                is_route_selection = True
                context = route_selection_context[context_thread_id]
                available_routes = context.get("available_routes", [])
                original_tool_args = context.get("original_args", {})
                
                # Parse user's route selection
                try:
                    numbers = re.findall(r'\d+', user_input)
                    if numbers:
                        route_number = int(numbers[0])
                        if 1 <= route_number <= len(available_routes):
                            selected_route = available_routes[route_number - 1]["route_id"]
                            user_selected_route = selected_route
                        else:
                            user_selected_route = "invalid"
                    else:
                        user_selected_route = "invalid"
                except:
                    user_selected_route = "invalid"

    # Get user query
    user_query = ""
    if messages:
        last = messages[-1]
        if isinstance(last, dict) and last.get("role") == "user":
            user_query = last.get("content", "") or ""
        elif isinstance(last, str):
            user_query = last

    async def event_stream() -> AsyncGenerator[str, None]:
        global last_thread_with_routes
        last_heartbeat = time.time()

        # --- RUN STARTED
        yield sse_event({"type": "RUN_STARTED", "thread_id": thread_id, "run_id": run_id})
        
        # --- CASE 1: Route Selection Response
        if is_route_selection:
            if user_selected_route == "invalid":
                # Invalid selection - show error and ask again
                yield sse_event({
                    "type": "TEXT_MESSAGE_CONTENT",
                    "message": {
                        "id": f"msg-{uuid.uuid4().hex[:8]}",
                        "role": "assistant",
                        "content": "‚ùå Invalid selection. Please enter only the route number (1, 2, 3, etc.)."
                    }
                })
                yield sse_event({"type": "STATE_UPDATE", "state": {"phase": "finished", "progress_pct": 100}})
                yield sse_event({"type": "RUN_FINISHED", "run_id": run_id})
                return
            
            # Valid route selected - process the actual query
            yield sse_event({
                "type": "STATE_UPDATE", 
                "state": {
                    "phase": "processing", 
                    "progress_pct": 50,
                    "message": f"üîÑ Fetching delay summary for route {user_selected_route}..."
                }
            })
            
            try:
                # Call the tool again with selected route
                tool_result = await mcp_client.invoke_tool(
                    "get_delay_summary", 
                    {**original_tool_args, "selected_route": user_selected_route}
                )
                
                # Clear the context
                if context_thread_id in route_selection_context:
                    route_selection_context.pop(context_thread_id)
                last_thread_with_routes = None
                
                # Process and display the actual delay summary
                if isinstance(tool_result, dict) and tool_result.get("ok"):
                    delay_data = tool_result['data']
                    
                    # Format the delay summary nicely
                    summary_parts = []
                    summary_parts.append(f"**‚úàÔ∏è Delay Summary for {user_selected_route}**")
                    summary_parts.append(f"**Flight:** {delay_data.get('flightLegState', {}).get('carrier', '')}{delay_data.get('flightLegState', {}).get('flightNumber', '')}")
                    summary_parts.append(f"**Date:** {delay_data.get('flightLegState', {}).get('dateOfOrigin', '')}")
                    summary_parts.append(f"**Route:** {delay_data.get('flightLegState', {}).get('startStation', '')} ‚Üí {delay_data.get('flightLegState', {}).get('endStation', '')}")
                    summary_parts.append(f"**Status:** {delay_data.get('flightLegState', {}).get('flightStatus', 'N/A')}")
                    
                    delays = delay_data.get('flightLegState', {}).get('delays', {})
                    if delays:
                        summary_parts.append("\n**Delays:**")
                        if isinstance(delays, list):
                            for delay in delays:
                                if isinstance(delay, dict):
                                    summary_parts.append(f"- Reason: {delay.get('reason', 'Unknown')}, Duration: {delay.get('duration', 'N/A')} minutes")
                        elif isinstance(delays, dict):
                            for key, value in delays.items():
                                summary_parts.append(f"- {key}: {value}")
                    
                    formatted_summary = "\n".join(summary_parts)
                    
                    yield sse_event({
                        "type": "TEXT_MESSAGE_CONTENT",
                        "message": {
                            "id": f"msg-{uuid.uuid4().hex[:8]}",
                            "role": "assistant",
                            "content": formatted_summary
                        }
                    })
                else:
                    yield sse_event({
                        "type": "TEXT_MESSAGE_CONTENT",
                        "message": {
                            "id": f"msg-{uuid.uuid4().hex[:8]}",
                            "role": "assistant", 
                            "content": f"‚ùå Error fetching delay summary: {tool_result}"
                        }
                    })
                    
            except Exception as e:
                yield sse_event({
                    "type": "TEXT_MESSAGE_CONTENT", 
                    "message": {
                        "id": f"msg-{uuid.uuid4().hex[:8]}",
                        "role": "assistant",
                        "content": f"‚ùå Error processing route selection: {str(e)}"
                    }
                })
            
            yield sse_event({"type": "STATE_UPDATE", "state": {"phase": "finished", "progress_pct": 100}})
            yield sse_event({"type": "RUN_FINISHED", "run_id": run_id})
            return

        # --- CASE 2: New Query (Normal Flow)
        if not user_query.strip():
            raise HTTPException(status_code=400, detail="No user query found")

        # THINKING: Initial analysis
        yield sse_event({
            "type": "STATE_UPDATE", 
            "state": {
                "phase": "thinking", 
                "progress_pct": 5,
                "message": "üß† Analyzing your flight query..."
            }
        })

        # ensure MCP
        try:
            await ensure_mcp_connected()
        except Exception as e:
            yield sse_event({"type": "RUN_ERROR", "error": f"MCP connect failed: {e}"})
            return

        loop = asyncio.get_event_loop()

        # --- PLAN (THINKING phase)
        yield sse_event({
            "type": "STATE_UPDATE", 
            "state": {
                "phase": "thinking", 
                "progress_pct": 15,
                "message": "üìã Planning which flight data tools to use..."
            }
        })
        
        try:
            plan_data = await loop.run_in_executor(None, mcp_client.plan_tools, user_query)
        except Exception as e:
            yield sse_event({"type": "RUN_ERROR", "error": f"Planner error: {e}"})
            return

        plan = plan_data.get("plan", []) if isinstance(plan_data, dict) else []
        planning_usage = plan_data.get("llm_usage", {})
        
        # DEBUG: Send token usage for planning
        print(f"DEBUG: Planning token usage: {planning_usage}")
        if planning_usage:
            yield sse_event({
                "type": "TOKEN_USAGE",
                "phase": "planning",
                "usage": planning_usage
            })
        
        yield sse_event({"type": "STATE_SNAPSHOT", "snapshot": {"plan": plan}})

        if not plan:
            yield sse_event({
                "type": "TEXT_MESSAGE_CONTENT", 
                "message": {
                    "id": f"msg-{uuid.uuid4().hex[:8]}",
                    "role": "assistant",
                    "content": "I couldn't generate a valid plan for your query. Please try rephrasing."
                }
            })
            yield sse_event({"type": "STATE_UPDATE", "state": {"phase": "finished", "progress_pct": 100}})
            yield sse_event({"type": "RUN_FINISHED", "run_id": run_id})
            return

        # --- PROCESSING: Tool execution
        yield sse_event({
            "type": "STATE_UPDATE", 
            "state": {
                "phase": "processing", 
                "progress_pct": 20,
                "message": f"üõ†Ô∏è Executing {len(plan)} flight data tools..."
            }
        })

        results = []
        num_steps = max(1, len(plan))
        per_step = 60.0 / num_steps
        current_progress = 20.0

        for step_index, step in enumerate(plan):
            if await request.is_disconnected():
                return

            tool_name = step.get("tool")
            args = step.get("arguments", {}) or {}

            yield sse_event({
                "type": "STATE_UPDATE", 
                "state": {
                    "phase": "processing",
                    "progress_pct": round(current_progress),
                    "message": f"üîß Running {tool_name}..."
                }
            })

            tool_call_id = f"toolcall-{uuid.uuid4().hex[:8]}"
            
            yield sse_event({
                "type": "TOOL_CALL_START",
                "toolCallId": tool_call_id,
                "toolCallName": tool_name,
                "parentMessageId": None
            })

            yield sse_event({
                "type": "TOOL_CALL_ARGS",
                "toolCallId": tool_call_id,
                "delta": json.dumps(args, ensure_ascii=False)
            })
            yield sse_event({"type": "TOOL_CALL_END", "toolCallId": tool_call_id})

            try:
                tool_result = await mcp_client.invoke_tool(tool_name, args)
                
                # Check if multiple routes are available (for delay summary)
                if (tool_name == "get_delay_summary" and 
                    isinstance(tool_result, dict) and 
                    tool_result.get("ok") and 
                    tool_result.get("data", {}).get("status") == "route_selection_required"):
                    
                    # Store context for route selection
                    route_data = tool_result["data"]
                    route_selection_context[thread_id] = {
                        "available_routes": route_data["available_routes"],
                        "original_args": args
                    }
                    last_thread_with_routes = thread_id  # Remember last thread
                    
                    # Format route options for display
                    route_options = []
                    for idx, route in enumerate(route_data["available_routes"]):
                        route_options.append(
                            f"**{idx+1}. {route['startStation']} ‚Üí {route['endStation']}**\n"
                            f"   - Time: {route.get('scheduledStartTime', 'Unknown')}\n"
                            f"   - Status: {route['flightStatus']}"
                        )
                    
                    route_message = "\n\n".join(route_options)
                    
                    yield sse_event({
                        "type": "TEXT_MESSAGE_CONTENT",
                        "message": {
                            "id": f"msg-{uuid.uuid4().hex[:8]}",
                            "role": "assistant",
                            "content": f"**üõ´ Multiple Routes Found!**\n\n"
                                      f"{route_message}\n\n"
                                      f"**Please select a route by entering the number (1-{len(route_data['available_routes'])}):**"
                        }
                    })
                    
                    # Stop further processing - wait for user route selection
                    yield sse_event({"type": "STATE_UPDATE", "state": {"phase": "finished", "progress_pct": 100}})
                    yield sse_event({"type": "RUN_FINISHED", "run_id": run_id})
                    return
                    
            except Exception as exc:
                tool_result = {"error": str(exc)}

            yield sse_event({
                "type": "TOOL_CALL_RESULT",
                "message": {
                    "id": f"msg-{uuid.uuid4().hex[:8]}",
                    "role": "tool",
                    "content": json.dumps(tool_result, ensure_ascii=False),
                    "tool_call_id": tool_call_id,
                }
            })
            results.append({tool_name: tool_result})

            yield sse_event({
                "type": "STEP_FINISHED",
                "step_index": step_index,
                "tool": tool_name
            })

            current_progress = min(80.0, 20.0 + per_step * (step_index + 1))
            
            if time.time() - last_heartbeat > 15:
                yield sse_event({"type": "HEARTBEAT", "ts": time.time()})
                last_heartbeat = time.time()

        # --- TYPING: Result generation
        yield sse_event({
            "type": "STATE_UPDATE", 
            "state": {
                "phase": "typing", 
                "progress_pct": 85,
                "message": "‚úçÔ∏è Generating your flight analysis..."
            }
        })

        try:
            summary_data = await loop.run_in_executor(None, mcp_client.summarize_results, user_query, plan, results)
            assistant_text = summary_data.get("summary", "") if isinstance(summary_data, dict) else str(summary_data)
            summarization_usage = summary_data.get("llm_usage", {})
            
            # DEBUG: Send token usage for summarization
            print(f"DEBUG: Summarization token usage: {summarization_usage}")
            if summarization_usage:
                yield sse_event({
                    "type": "TOKEN_USAGE",
                    "phase": "summarization", 
                    "usage": summarization_usage
                })
                
                # Calculate and send total token usage
                def safe_int(val):
                    return val if isinstance(val, int) else 0
                    
                total_usage = {
                    "prompt_tokens": safe_int(planning_usage.get('prompt_tokens', 0)) + safe_int(summarization_usage.get('prompt_tokens', 0)),
                    "completion_tokens": safe_int(planning_usage.get('completion_tokens', 0)) + safe_int(summarization_usage.get('completion_tokens', 0)),
                    "total_tokens": safe_int(planning_usage.get('total_tokens', 0)) + safe_int(summarization_usage.get('total_tokens', 0))
                }
                
                print(f"DEBUG: Total token usage: {total_usage}")
                yield sse_event({
                    "type": "TOKEN_USAGE",
                    "phase": "total",
                    "usage": total_usage
                })
                
        except Exception as e:
            assistant_text = f"‚ùå Failed to summarize results: {e}"

        # Stream summary as chunks
        msg_id = f"msg-{uuid.uuid4().hex[:8]}"
        
        yield sse_event({
            "type": "TEXT_MESSAGE_CONTENT",
            "message": {
                "id": msg_id,
                "role": "assistant",
                "content": ""
            }
        })

        chunks = chunk_text(assistant_text, max_len=150)
        for i, chunk in enumerate(chunks):
            yield sse_event({
                "type": "TEXT_MESSAGE_CONTENT",
                "message": {
                    "id": msg_id,
                    "role": "assistant", 
                    "delta": chunk
                }
            })
            
            typing_progress = 85 + (i / len(chunks)) * 15
            yield sse_event({
                "type": "STATE_UPDATE",
                "state": {
                    "phase": "typing",
                    "progress_pct": round(typing_progress),
                    "message": "‚úçÔ∏è Generating your flight analysis..."
                }
            })
            
            await asyncio.sleep(0.03)

        # Final state
        yield sse_event({"type": "STATE_SNAPSHOT", "snapshot": {"plan": plan, "results": results}})
        yield sse_event({
            "type": "STATE_UPDATE", 
            "state": {
                "phase": "finished", 
                "progress_pct": 100,
                "message": "‚úÖ Analysis complete"
            }
        })
        yield sse_event({"type": "RUN_FINISHED", "run_id": run_id})

    return StreamingResponse(event_stream(), media_type="text/event-stream")
######################################################


INFO:     Waiting for application startup.
INFO:FlightOps.MCPClient:Connecting to MCP server at http://127.0.0.1:8000/mcp
INFO:httpx:HTTP Request: POST http://127.0.0.1:8000/mcp "HTTP/1.1 200 OK"
INFO:mcp.client.streamable_http:Received session ID: b7b297a158ed4a7d971c68c00390366e
INFO:mcp.client.streamable_http:Negotiated protocol version: 2025-06-18
INFO:FlightOps.MCPClient:‚úÖ Connected to MCP server successfully
INFO:     Application startup complete.
INFO:httpx:HTTP Request: POST http://127.0.0.1:8000/mcp "HTTP/1.1 202 Accepted"
INFO:httpx:HTTP Request: GET http://127.0.0.1:8000/mcp "HTTP/1.1 200 OK"
INFO:     127.0.0.1:51259 - "OPTIONS /agent HTTP/1.1" 200 OK
============================================================
üéØ DEBUG 1: NEW REQUEST RECEIVED
üéØ Thread ID: thread-1763705052269
üéØ Run ID: run-1763705052269
üéØ Total messages: 1
üéØ Current route_selection_context keys: []
üéØ Message 0: user - give delay info for flight 6e215 on 2024-06-23...
============================================================
üéØ DEBUG 3: CHECKING ROUTE SELECTION CONTEXT
üéØ Looking for thread_id: thread-1763705052269
üéØ All context keys: []
üéØ ‚ùå THREAD ID NOT FOUND IN CONTEXT
üéØ Final is_route_selection: False, user_selected_route: None
INFO:     127.0.0.1:51259 - "POST /agent HTTP/1.1" 200 OK
INFO:httpx:HTTP Request: POST https://6e-openai-sandbox-aops.openai.azure.com/openai/deployments/gpt-4o/chat/completions?api-version=2024-12-01-preview "HTTP/1.1 200 OK"
üéØ üìã GENERATED PLAN: [{'tool': 'get_delay_summary', 'arguments': {'carrier': '6E', 'flight_number': '215', 'date_of_origin': '2024-06-23'}}]
DEBUG: Planning token usage: {'prompt_tokens': 1715, 'completion_tokens': 64, 'total_tokens': 1779}
üéØ üîß EXECUTING TOOL: get_delay_summary with args: {'carrier': '6E', 'flight_number': '215', 'date_of_origin': '2024-06-23'}
INFO:FlightOps.MCPClient:Calling tool: get_delay_summary with args: {'carrier': '6E', 'flight_number': '215', 'date_of_origin': '2024-06-23'}
INFO:httpx:HTTP Request: POST http://127.0.0.1:8000/mcp "HTTP/1.1 200 OK"
INFO:httpx:HTTP Request: POST http://127.0.0.1:8000/mcp "HTTP/1.1 200 OK"
üéØ DEBUG 2: TOOL EXECUTION RESULT
üéØ Tool Name: get_delay_summary
üéØ Tool Args: {'carrier': '6E', 'flight_number': '215', 'date_of_origin': '2024-06-23'}
üéØ Tool Result Type: <class 'dict'>
üéØ Tool Result Keys: dict_keys(['ok', 'data'])
üéØ Tool Result OK: True
üéØ Tool Data Keys: dict_keys(['status', 'multiple_routes', 'message', 'available_routes', 'instruction', 'next_step']) 
üéØ Tool Data Status: route_selection_required
üéØ Checking for route selection requirement...
üéØ Data status: route_selection_required
üéØ ‚úÖ ROUTE SELECTION REQUIRED - Storing context...
üéØ ‚úÖ CONTEXT STORED for thread: thread-1763705052269
üéØ Available routes count: 2
üéØ Now route_selection_context has keys: ['thread-1763705052269']
============================================================
üéØ DEBUG 1: NEW REQUEST RECEIVED
üéØ Thread ID: thread-1763705062522
üéØ Run ID: run-1763705062522
üéØ Total messages: 1
üéØ Current route_selection_context keys: ['thread-1763705052269']
üéØ Message 0: user - 1...
============================================================
üéØ DEBUG 3: CHECKING ROUTE SELECTION CONTEXT
üéØ Looking for thread_id: thread-1763705062522
üéØ All context keys: ['thread-1763705052269']
üéØ ‚ùå THREAD ID NOT FOUND IN CONTEXT
üéØ Final is_route_selection: False, user_selected_route: None
INFO:     127.0.0.1:61486 - "POST /agent HTTP/1.1" 200 OK
INFO:httpx:HTTP Request: POST https://6e-openai-sandbox-aops.openai.azure.com/openai/deployments/gpt-4o/chat/completions?api-version=2024-12-01-preview "HTTP/1.1 200 OK"
üéØ üìã GENERATED PLAN: []
DEBUG: Planning token usage: {'prompt_tokens': 1699, 'completion_tokens': 12, 'total_tokens': 1711}
(ye ag_ui_mai error debug kr ra h ki option choose krne ke bad dobara tool kuni run ho ra h)
#################################################################################
import os
import json
import asyncio
import time
import uuid
import re
from typing import AsyncGenerator, List
from fastapi import FastAPI, Request, HTTPException
from fastapi.responses import StreamingResponse
from fastapi.middleware.cors import CORSMiddleware
from client import FlightOpsMCPClient

app = FastAPI(title="FlightOps ‚Äî AG-UI Adapter")

# CORS (adjust origins for your Vite origin)
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

mcp_client = FlightOpsMCPClient()

# Global context storage for route selection
route_selection_context = {}

def sse_event(data: dict) -> str:
    """Encode one SSE event (JSON payload)"""
    return f"data: {json.dumps(data, default=str, ensure_ascii=False)}\n\n"

async def ensure_mcp_connected():
    if not mcp_client.session:
        await mcp_client.connect()

@app.on_event("startup")
async def startup_event():
    try:
        await ensure_mcp_connected()
    except Exception:
        pass

@app.get("/")
async def root():
    return {"message": "FlightOps AG-UI Adapter running", "status": "ok"}

@app.get("/health")
async def health():
    try:
        await ensure_mcp_connected()
        return {"status": "healthy", "mcp_connected": True}
    except Exception as e:
        return {"status": "unhealthy", "mcp_connected": False, "error": str(e)}

def chunk_text(txt: str, max_len: int = 200) -> List[str]:
    txt = txt or ""
    parts: List[str] = []
    buf = ""

    def flush():
        nonlocal buf
        if buf:
            parts.append(buf)
            buf = ""

    for ch in txt:
        buf += ch
        if ch in ".!?\n" and len(buf) >= max_len // 2:
            flush()
        elif len(buf) >= max_len:
            flush()
    flush()
    return parts

@app.post("/agent", response_class=StreamingResponse)
async def run_agent(request: Request):
    try:
        body = await request.json()
    except Exception:
        raise HTTPException(status_code=400, detail="Invalid JSON body")

    thread_id = body.get("thread_id") or f"thread-{uuid.uuid4().hex[:8]}"
    run_id = body.get("run_id") or f"run-{uuid.uuid4().hex[:8]}"
    messages = body.get("messages", [])
    
    # üéØ DEBUG CODE 1: NEW REQUEST
    print("=" * 60)
    print("üéØ DEBUG 1: NEW REQUEST RECEIVED")
    print(f"üéØ Thread ID: {thread_id}")
    print(f"üéØ Run ID: {run_id}")
    print(f"üéØ Total messages: {len(messages)}")
    print(f"üéØ Current route_selection_context keys: {list(route_selection_context.keys())}")
    if messages:
        for i, msg in enumerate(messages):
            print(f"üéØ Message {i}: {msg.get('role', 'unknown')} - {msg.get('content', '')[:100]}...")
    print("=" * 60)
    
    # üéØ DEBUG CODE 3: ROUTE SELECTION CONTEXT CHECK
    print("üéØ DEBUG 3: CHECKING ROUTE SELECTION CONTEXT")
    print(f"üéØ Looking for thread_id: {thread_id}")
    print(f"üéØ All context keys: {list(route_selection_context.keys())}")
    
    is_route_selection = False
    user_selected_route = None
    original_tool_args = None
    
    if thread_id in route_selection_context:
        print("üéØ ‚úÖ THREAD ID FOUND IN CONTEXT!")
        context = route_selection_context[thread_id]
        print(f"üéØ Context data keys: {context.keys()}")
        
        # This is a follow-up message for route selection
        if messages:
            last_message = messages[-1]
            if isinstance(last_message, dict) and last_message.get("role") == "user":
                user_input = last_message.get("content", "").strip()
                print(f"üéØ User input for route selection: '{user_input}'")
                
                is_route_selection = True
                available_routes = context.get("available_routes", [])
                original_tool_args = context.get("original_args", {})
                
                print(f"üéØ Available routes count: {len(available_routes)}")
                print(f"üéØ Original args: {original_tool_args}")
                
                # Parse user's route selection
                try:
                    numbers = re.findall(r'\d+', user_input)
                    print(f"üéØ Extracted numbers: {numbers}")
                    
                    if numbers:
                        route_number = int(numbers[0])
                        print(f"üéØ Route number: {route_number}")
                        
                        if 1 <= route_number <= len(available_routes):
                            selected_route = available_routes[route_number - 1]["route_id"]
                            user_selected_route = selected_route
                            print(f"üéØ ‚úÖ VALID SELECTION - Route: {selected_route}")
                            print(f"üéØ Selected route details: {available_routes[route_number - 1]}")
                        else:
                            user_selected_route = "invalid"
                            print(f"üéØ ‚ùå INVALID ROUTE NUMBER: {route_number}, available: 1-{len(available_routes)}")
                    else:
                        user_selected_route = "invalid"
                        print(f"üéØ ‚ùå NO NUMBERS FOUND in input: '{user_input}'")
                except Exception as e:
                    user_selected_route = "invalid"
                    print(f"üéØ ‚ùå ERROR PARSING: {e}")
    else:
        print("üéØ ‚ùå THREAD ID NOT FOUND IN CONTEXT")
    
    # Get user query
    user_query = ""
    if messages:
        last = messages[-1]
        if isinstance(last, dict) and last.get("role") == "user":
            user_query = last.get("content", "") or ""
        elif isinstance(last, str):
            user_query = last

    print(f"üéØ Final is_route_selection: {is_route_selection}, user_selected_route: {user_selected_route}")

    async def event_stream() -> AsyncGenerator[str, None]:
        last_heartbeat = time.time()

        # --- RUN STARTED
        yield sse_event({"type": "RUN_STARTED", "thread_id": thread_id, "run_id": run_id})
        
        # --- CASE 1: Route Selection Response
        if is_route_selection:
            print("üéØ üöÄ PROCESSING ROUTE SELECTION RESPONSE")
            
            if user_selected_route == "invalid":
                # Invalid selection - show error and ask again
                print("üéØ ‚ùå INVALID ROUTE SELECTION - Showing error")
                yield sse_event({
                    "type": "TEXT_MESSAGE_CONTENT",
                    "message": {
                        "id": f"msg-{uuid.uuid4().hex[:8]}",
                        "role": "assistant",
                        "content": "‚ùå Invalid selection. Please enter only the route number (1, 2, 3, etc.)."
                    }
                })
                yield sse_event({"type": "STATE_UPDATE", "state": {"phase": "finished", "progress_pct": 100}})
                yield sse_event({"type": "RUN_FINISHED", "run_id": run_id})
                return
            
            # Valid route selected - process the actual query
            yield sse_event({
                "type": "STATE_UPDATE", 
                "state": {
                    "phase": "processing", 
                    "progress_pct": 50,
                    "message": f"üîÑ Fetching delay summary for route {user_selected_route}..."
                }
            })
            
            try:
                # Call the tool again with selected route
                print(f"üéØ üîß CALLING get_delay_summary WITH SELECTED ROUTE")
                print(f"üéØ Original args: {original_tool_args}")
                print(f"üéØ Selected route: {user_selected_route}")
                
                final_args = {**original_tool_args, "selected_route": user_selected_route}
                print(f"üéØ Final args for tool call: {final_args}")
                
                tool_result = await mcp_client.invoke_tool("get_delay_summary", final_args)
                
                print(f"üéØ üîß TOOL RESULT WITH SELECTED ROUTE: {json.dumps(tool_result, indent=2)}")
                
                # Clear the context
                if thread_id in route_selection_context:
                    route_selection_context.pop(thread_id)
                    print(f"üéØ ‚úÖ CONTEXT CLEARED for thread: {thread_id}")
                
                # Process and display the actual delay summary
                if isinstance(tool_result, dict) and tool_result.get("ok"):
                    delay_data = tool_result['data']
                    
                    # Format the delay summary nicely
                    summary_parts = []
                    summary_parts.append(f"**‚úàÔ∏è Delay Summary for {user_selected_route}**")
                    summary_parts.append(f"**Flight:** {delay_data.get('flightLegState', {}).get('carrier', '')}{delay_data.get('flightLegState', {}).get('flightNumber', '')}")
                    summary_parts.append(f"**Date:** {delay_data.get('flightLegState', {}).get('dateOfOrigin', '')}")
                    summary_parts.append(f"**Route:** {delay_data.get('flightLegState', {}).get('startStation', '')} ‚Üí {delay_data.get('flightLegState', {}).get('endStation', '')}")
                    summary_parts.append(f"**Status:** {delay_data.get('flightLegState', {}).get('flightStatus', 'N/A')}")
                    
                    delays = delay_data.get('flightLegState', {}).get('delays', {})
                    if delays:
                        summary_parts.append("\n**Delays:**")
                        if isinstance(delays, list):
                            for delay in delays:
                                if isinstance(delay, dict):
                                    reason = delay.get('reason', 'Unknown')
                                    duration = delay.get('duration', 'N/A')
                                    summary_parts.append(f"- **{reason}**: {duration} minutes")
                        elif isinstance(delays, dict):
                            for key, value in delays.items():
                                summary_parts.append(f"- **{key}**: {value}")
                    
                    formatted_summary = "\n".join(summary_parts)
                    
                    yield sse_event({
                        "type": "TEXT_MESSAGE_CONTENT",
                        "message": {
                            "id": f"msg-{uuid.uuid4().hex[:8]}",
                            "role": "assistant",
                            "content": formatted_summary
                        }
                    })
                else:
                    error_msg = tool_result.get('error', 'Unknown error') if isinstance(tool_result, dict) else str(tool_result)
                    yield sse_event({
                        "type": "TEXT_MESSAGE_CONTENT",
                        "message": {
                            "id": f"msg-{uuid.uuid4().hex[:8]}",
                            "role": "assistant", 
                            "content": f"‚ùå Error fetching delay summary: {error_msg}"
                        }
                    })
                    
            except Exception as e:
                print(f"üéØ ‚ùå EXCEPTION IN ROUTE SELECTION: {e}")
                yield sse_event({
                    "type": "TEXT_MESSAGE_CONTENT", 
                    "message": {
                        "id": f"msg-{uuid.uuid4().hex[:8]}",
                        "role": "assistant",
                        "content": f"‚ùå Error processing route selection: {str(e)}"
                    }
                })
            
            yield sse_event({"type": "STATE_UPDATE", "state": {"phase": "finished", "progress_pct": 100}})
            yield sse_event({"type": "RUN_FINISHED", "run_id": run_id})
            return

        # --- CASE 2: New Query (Normal Flow)
        if not user_query.strip():
            raise HTTPException(status_code=400, detail="No user query found")

        # THINKING: Initial analysis
        yield sse_event({
            "type": "STATE_UPDATE", 
            "state": {
                "phase": "thinking", 
                "progress_pct": 5,
                "message": "üß† Analyzing your flight query..."
            }
        })

        # ensure MCP
        try:
            await ensure_mcp_connected()
        except Exception as e:
            yield sse_event({"type": "RUN_ERROR", "error": f"MCP connect failed: {e}"})
            return

        loop = asyncio.get_event_loop()

        # --- PLAN (THINKING phase)
        yield sse_event({
            "type": "STATE_UPDATE", 
            "state": {
                "phase": "thinking", 
                "progress_pct": 15,
                "message": "üìã Planning which flight data tools to use..."
            }
        })
        
        try:
            plan_data = await loop.run_in_executor(None, mcp_client.plan_tools, user_query)
        except Exception as e:
            yield sse_event({"type": "RUN_ERROR", "error": f"Planner error: {e}"})
            return

        plan = plan_data.get("plan", []) if isinstance(plan_data, dict) else []
        planning_usage = plan_data.get("llm_usage", {})
        
        print(f"üéØ üìã GENERATED PLAN: {plan}")
        
        # DEBUG: Send token usage for planning
        print(f"DEBUG: Planning token usage: {planning_usage}")
        if planning_usage:
            yield sse_event({
                "type": "TOKEN_USAGE",
                "phase": "planning",
                "usage": planning_usage
            })
        
        yield sse_event({"type": "STATE_SNAPSHOT", "snapshot": {"plan": plan}})

        if not plan:
            yield sse_event({
                "type": "TEXT_MESSAGE_CONTENT", 
                "message": {
                    "id": f"msg-{uuid.uuid4().hex[:8]}",
                    "role": "assistant",
                    "content": "I couldn't generate a valid plan for your query. Please try rephrasing."
                }
            })
            yield sse_event({"type": "STATE_UPDATE", "state": {"phase": "finished", "progress_pct": 100}})
            yield sse_event({"type": "RUN_FINISHED", "run_id": run_id})
            return

        # --- PROCESSING: Tool execution
        yield sse_event({
            "type": "STATE_UPDATE", 
            "state": {
                "phase": "processing", 
                "progress_pct": 20,
                "message": f"üõ†Ô∏è Executing {len(plan)} flight data tools..."
            }
        })

        results = []
        num_steps = max(1, len(plan))
        per_step = 60.0 / num_steps
        current_progress = 20.0

        for step_index, step in enumerate(plan):
            if await request.is_disconnected():
                return

            tool_name = step.get("tool")
            args = step.get("arguments", {}) or {}

            print(f"üéØ üîß EXECUTING TOOL: {tool_name} with args: {args}")

            yield sse_event({
                "type": "STATE_UPDATE", 
                "state": {
                    "phase": "processing",
                    "progress_pct": round(current_progress),
                    "message": f"üîß Running {tool_name}..."
                }
            })

            tool_call_id = f"toolcall-{uuid.uuid4().hex[:8]}"
            
            yield sse_event({
                "type": "TOOL_CALL_START",
                "toolCallId": tool_call_id,
                "toolCallName": tool_name,
                "parentMessageId": None
            })

            yield sse_event({
                "type": "TOOL_CALL_ARGS",
                "toolCallId": tool_call_id,
                "delta": json.dumps(args, ensure_ascii=False)
            })
            yield sse_event({"type": "TOOL_CALL_END", "toolCallId": tool_call_id})

            try:
                tool_result = await mcp_client.invoke_tool(tool_name, args)
                
                # üéØ DEBUG CODE 2: TOOL EXECUTION RESULT
                print("üéØ DEBUG 2: TOOL EXECUTION RESULT")
                print(f"üéØ Tool Name: {tool_name}")
                print(f"üéØ Tool Args: {args}")
                print(f"üéØ Tool Result Type: {type(tool_result)}")
                if isinstance(tool_result, dict):
                    print(f"üéØ Tool Result Keys: {tool_result.keys()}")
                    print(f"üéØ Tool Result OK: {tool_result.get('ok')}")
                    if tool_result.get('data'):
                        print(f"üéØ Tool Data Keys: {tool_result['data'].keys()}")
                        print(f"üéØ Tool Data Status: {tool_result['data'].get('status')}")
                
                # Check if multiple routes are available (for delay summary)
                if (tool_name == "get_delay_summary" and 
                    isinstance(tool_result, dict) and 
                    tool_result.get("ok")):
                    
                    data = tool_result.get("data", {})
                    print(f"üéØ Checking for route selection requirement...")
                    print(f"üéØ Data status: {data.get('status')}")
                    
                    if data.get("status") == "route_selection_required":
                        print("üéØ ‚úÖ ROUTE SELECTION REQUIRED - Storing context...")
                        
                        # Store context for route selection
                        route_selection_context[thread_id] = {
                            "available_routes": data["available_routes"],
                            "original_args": args
                        }
                        
                        print(f"üéØ ‚úÖ CONTEXT STORED for thread: {thread_id}")
                        print(f"üéØ Available routes count: {len(data['available_routes'])}")
                        print(f"üéØ Now route_selection_context has keys: {list(route_selection_context.keys())}")
                        
                        # Format route options for display
                        route_options = []
                        for idx, route in enumerate(data["available_routes"]):
                            route_options.append(
                                f"**{idx+1}. {route['startStation']} ‚Üí {route['endStation']}**\n"
                                f"   - Time: {route.get('scheduledStartTime', 'Unknown')}\n"
                                f"   - Status: {route['flightStatus']}"
                            )
                        
                        route_message = "\n\n".join(route_options)
                        
                        yield sse_event({
                            "type": "TEXT_MESSAGE_CONTENT",
                            "message": {
                                "id": f"msg-{uuid.uuid4().hex[:8]}",
                                "role": "assistant",
                                "content": f"**üõ´ Multiple Routes Found!**\n\n"
                                          f"{route_message}\n\n"
                                          f"**Please select a route by entering the number (1-{len(data['available_routes']}):**"
                            }
                        })
                        
                        # Stop further processing - wait for user route selection
                        yield sse_event({"type": "STATE_UPDATE", "state": {"phase": "finished", "progress_pct": 100}})
                        yield sse_event({"type": "RUN_FINISHED", "run_id": run_id})
                        return
                    else:
                        print("üéØ ‚ùå No route selection required or different status")
                else:
                    print("üéØ ‚ùå Not get_delay_summary or tool failed")
                # üéØ DEBUG CODE 2 ENDS HERE
                    
            except Exception as exc:
                tool_result = {"error": str(exc)}
                print(f"üéØ ‚ùå TOOL ERROR: {exc}")

            yield sse_event({
                "type": "TOOL_CALL_RESULT",
                "message": {
                    "id": f"msg-{uuid.uuid4().hex[:8]}",
                    "role": "tool",
                    "content": json.dumps(tool_result, ensure_ascii=False),
                    "tool_call_id": tool_call_id,
                }
            })
            results.append({tool_name: tool_result})

            yield sse_event({
                "type": "STEP_FINISHED",
                "step_index": step_index,
                "tool": tool_name
            })

            current_progress = min(80.0, 20.0 + per_step * (step_index + 1))
            
            if time.time() - last_heartbeat > 15:
                yield sse_event({"type": "HEARTBEAT", "ts": time.time()})
                last_heartbeat = time.time()

        # --- TYPING: Result generation
        yield sse_event({
            "type": "STATE_UPDATE", 
            "state": {
                "phase": "typing", 
                "progress_pct": 85,
                "message": "‚úçÔ∏è Generating your flight analysis..."
            }
        })

        try:
            summary_data = await loop.run_in_executor(None, mcp_client.summarize_results, user_query, plan, results)
            assistant_text = summary_data.get("summary", "") if isinstance(summary_data, dict) else str(summary_data)
            summarization_usage = summary_data.get("llm_usage", {})
            
            # DEBUG: Send token usage for summarization
            print(f"DEBUG: Summarization token usage: {summarization_usage}")
            if summarization_usage:
                yield sse_event({
                    "type": "TOKEN_USAGE",
                    "phase": "summarization", 
                    "usage": summarization_usage
                })
                
                # Calculate and send total token usage
                def safe_int(val):
                    return val if isinstance(val, int) else 0
                    
                total_usage = {
                    "prompt_tokens": safe_int(planning_usage.get('prompt_tokens', 0)) + safe_int(summarization_usage.get('prompt_tokens', 0)),
                    "completion_tokens": safe_int(planning_usage.get('completion_tokens', 0)) + safe_int(summarization_usage.get('completion_tokens', 0)),
                    "total_tokens": safe_int(planning_usage.get('total_tokens', 0)) + safe_int(summarization_usage.get('total_tokens', 0))
                }
                
                print(f"DEBUG: Total token usage: {total_usage}")
                yield sse_event({
                    "type": "TOKEN_USAGE",
                    "phase": "total",
                    "usage": total_usage
                })
                
        except Exception as e:
            assistant_text = f"‚ùå Failed to summarize results: {e}"

        # Stream summary as chunks
        msg_id = f"msg-{uuid.uuid4().hex[:8]}"
        
        yield sse_event({
            "type": "TEXT_MESSAGE_CONTENT",
            "message": {
                "id": msg_id,
                "role": "assistant",
                "content": ""
            }
        })

        chunks = chunk_text(assistant_text, max_len=150)
        for i, chunk in enumerate(chunks):
            yield sse_event({
                "type": "TEXT_MESSAGE_CONTENT",
                "message": {
                    "id": msg_id,
                    "role": "assistant", 
                    "delta": chunk
                }
            })
            
            typing_progress = 85 + (i / len(chunks)) * 15
            yield sse_event({
                "type": "STATE_UPDATE",
                "state": {
                    "phase": "typing",
                    "progress_pct": round(typing_progress),
                    "message": "‚úçÔ∏è Generating your flight analysis..."
                }
            })
            
            await asyncio.sleep(0.03)

        # Final state
        yield sse_event({"type": "STATE_SNAPSHOT", "snapshot": {"plan": plan, "results": results}})
        yield sse_event({
            "type": "STATE_UPDATE", 
            "state": {
                "phase": "finished", 
                "progress_pct": 100,
                "message": "‚úÖ Analysis complete"
            }
        })
        yield sse_event({"type": "RUN_FINISHED", "run_id": run_id})

    return StreamingResponse(event_stream(), media_type="text/event-stream")
