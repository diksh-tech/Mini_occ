import os
import json
import asyncio
import time
import uuid
import re
from typing import AsyncGenerator, List
from fastapi import FastAPI, Request, HTTPException
from fastapi.responses import StreamingResponse
from fastapi.middleware.cors import CORSMiddleware
from client import FlightOpsMCPClient

app = FastAPI(title="FlightOps â€” AG-UI Adapter")

# CORS (adjust origins for your Vite origin)
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

mcp_client = FlightOpsMCPClient()

# Global context storage for route selection
route_selection_context = {}

def sse_event(data: dict) -> str:
    """Encode one SSE event (JSON payload)"""
    return f"data: {json.dumps(data, default=str, ensure_ascii=False)}\n\n"

async def ensure_mcp_connected():
    if not mcp_client.session:
        await mcp_client.connect()

@app.on_event("startup")
async def startup_event():
    try:
        await ensure_mcp_connected()
    except Exception:
        pass

@app.get("/")
async def root():
    return {"message": "FlightOps AG-UI Adapter running", "status": "ok"}

@app.get("/health")
async def health():
    try:
        await ensure_mcp_connected()
        return {"status": "healthy", "mcp_connected": True}
    except Exception as e:
        return {"status": "unhealthy", "mcp_connected": False, "error": str(e)}

def chunk_text(txt: str, max_len: int = 200) -> List[str]:
    txt = txt or ""
    parts: List[str] = []
    buf = ""

    def flush():
        nonlocal buf
        if buf:
            parts.append(buf)
            buf = ""

    for ch in txt:
        buf += ch
        if ch in ".!?\n" and len(buf) >= max_len // 2:
            flush()
        elif len(buf) >= max_len:
            flush()
    flush()
    return parts

@app.post("/agent", response_class=StreamingResponse)
async def run_agent(request: Request):
    try:
        body = await request.json()
    except Exception:
        raise HTTPException(status_code=400, detail="Invalid JSON body")

    thread_id = body.get("thread_id") or f"thread-{uuid.uuid4().hex[:8]}"
    run_id = body.get("run_id") or f"run-{uuid.uuid4().hex[:8]}"
    messages = body.get("messages", [])
    
    # ğŸ¯ DEBUG CODE 1: NEW REQUEST
    print("=" * 60)
    print("ğŸ¯ DEBUG 1: NEW REQUEST RECEIVED")
    print(f"ğŸ¯ Thread ID: {thread_id}")
    print(f"ğŸ¯ Run ID: {run_id}")
    print(f"ğŸ¯ Total messages: {len(messages)}")
    print(f"ğŸ¯ Current route_selection_context keys: {list(route_selection_context.keys())}")
    if messages:
        for i, msg in enumerate(messages):
            print(f"ğŸ¯ Message {i}: {msg.get('role', 'unknown')} - {msg.get('content', '')[:100]}...")
    print("=" * 60)
    
    # ğŸ¯ DEBUG CODE 3: ROUTE SELECTION CONTEXT CHECK
    print("ğŸ¯ DEBUG 3: CHECKING ROUTE SELECTION CONTEXT")
    print(f"ğŸ¯ Looking for thread_id: {thread_id}")
    print(f"ğŸ¯ All context keys: {list(route_selection_context.keys())}")
    
    is_route_selection = False
    user_selected_route = None
    original_tool_args = None
    
    if thread_id in route_selection_context:
        print("ğŸ¯ âœ… THREAD ID FOUND IN CONTEXT!")
        context = route_selection_context[thread_id]
        print(f"ğŸ¯ Context data keys: {context.keys()}")
        
        # This is a follow-up message for route selection
        if messages:
            last_message = messages[-1]
            if isinstance(last_message, dict) and last_message.get("role") == "user":
                user_input = last_message.get("content", "").strip()
                print(f"ğŸ¯ User input for route selection: '{user_input}'")
                
                is_route_selection = True
                available_routes = context.get("available_routes", [])
                original_tool_args = context.get("original_args", {})
                
                print(f"ğŸ¯ Available routes count: {len(available_routes)}")
                print(f"ğŸ¯ Original args: {original_tool_args}")
                
                # Parse user's route selection
                try:
                    numbers = re.findall(r'\d+', user_input)
                    print(f"ğŸ¯ Extracted numbers: {numbers}")
                    
                    if numbers:
                        route_number = int(numbers[0])
                        print(f"ğŸ¯ Route number: {route_number}")
                        
                        if 1 <= route_number <= len(available_routes):
                            selected_route = available_routes[route_number - 1]["route_id"]
                            user_selected_route = selected_route
                            print(f"ğŸ¯ âœ… VALID SELECTION - Route: {selected_route}")
                            print(f"ğŸ¯ Selected route details: {available_routes[route_number - 1]}")
                        else:
                            user_selected_route = "invalid"
                            print(f"ğŸ¯ âŒ INVALID ROUTE NUMBER: {route_number}, available: 1-{len(available_routes)}")
                    else:
                        user_selected_route = "invalid"
                        print(f"ğŸ¯ âŒ NO NUMBERS FOUND in input: '{user_input}'")
                except Exception as e:
                    user_selected_route = "invalid"
                    print(f"ğŸ¯ âŒ ERROR PARSING: {e}")
    else:
        print("ğŸ¯ âŒ THREAD ID NOT FOUND IN CONTEXT")
    
    # Get user query
    user_query = ""
    if messages:
        last = messages[-1]
        if isinstance(last, dict) and last.get("role") == "user":
            user_query = last.get("content", "") or ""
        elif isinstance(last, str):
            user_query = last

    print(f"ğŸ¯ Final is_route_selection: {is_route_selection}, user_selected_route: {user_selected_route}")

    async def event_stream() -> AsyncGenerator[str, None]:
        last_heartbeat = time.time()

        # --- RUN STARTED
        yield sse_event({"type": "RUN_STARTED", "thread_id": thread_id, "run_id": run_id})
        
        # --- CASE 1: Route Selection Response
        if is_route_selection:
            print("ğŸ¯ ğŸš€ PROCESSING ROUTE SELECTION RESPONSE")
            
            if user_selected_route == "invalid":
                # Invalid selection - show error and ask again
                print("ğŸ¯ âŒ INVALID ROUTE SELECTION - Showing error")
                yield sse_event({
                    "type": "TEXT_MESSAGE_CONTENT",
                    "message": {
                        "id": f"msg-{uuid.uuid4().hex[:8]}",
                        "role": "assistant",
                        "content": "âŒ Invalid selection. Please enter only the route number (1, 2, 3, etc.)."
                    }
                })
                yield sse_event({"type": "STATE_UPDATE", "state": {"phase": "finished", "progress_pct": 100}})
                yield sse_event({"type": "RUN_FINISHED", "run_id": run_id})
                return
            
            # Valid route selected - process the actual query
            yield sse_event({
                "type": "STATE_UPDATE", 
                "state": {
                    "phase": "processing", 
                    "progress_pct": 50,
                    "message": f"ğŸ”„ Fetching delay summary for route {user_selected_route}..."
                }
            })
            
            try:
                # Call the tool again with selected route
                print(f"ğŸ¯ ğŸ”§ CALLING get_delay_summary WITH SELECTED ROUTE")
                print(f"ğŸ¯ Original args: {original_tool_args}")
                print(f"ğŸ¯ Selected route: {user_selected_route}")
                
                final_args = {**original_tool_args, "selected_route": user_selected_route}
                print(f"ğŸ¯ Final args for tool call: {final_args}")
                
                tool_result = await mcp_client.invoke_tool("get_delay_summary", final_args)
                
                print(f"ğŸ¯ ğŸ”§ TOOL RESULT WITH SELECTED ROUTE: {json.dumps(tool_result, indent=2)}")
                
                # Clear the context
                if thread_id in route_selection_context:
                    route_selection_context.pop(thread_id)
                    print(f"ğŸ¯ âœ… CONTEXT CLEARED for thread: {thread_id}")
                
                # Process and display the actual delay summary
                if isinstance(tool_result, dict) and tool_result.get("ok"):
                    delay_data = tool_result['data']
                    
                    # Format the delay summary nicely
                    summary_parts = []
                    summary_parts.append(f"**âœˆï¸ Delay Summary for {user_selected_route}**")
                    summary_parts.append(f"**Flight:** {delay_data.get('flightLegState', {}).get('carrier', '')}{delay_data.get('flightLegState', {}).get('flightNumber', '')}")
                    summary_parts.append(f"**Date:** {delay_data.get('flightLegState', {}).get('dateOfOrigin', '')}")
                    summary_parts.append(f"**Route:** {delay_data.get('flightLegState', {}).get('startStation', '')} â†’ {delay_data.get('flightLegState', {}).get('endStation', '')}")
                    summary_parts.append(f"**Status:** {delay_data.get('flightLegState', {}).get('flightStatus', 'N/A')}")
                    
                    delays = delay_data.get('flightLegState', {}).get('delays', {})
                    if delays:
                        summary_parts.append("\n**Delays:**")
                        if isinstance(delays, list):
                            for delay in delays:
                                if isinstance(delay, dict):
                                    reason = delay.get('reason', 'Unknown')
                                    duration = delay.get('duration', 'N/A')
                                    summary_parts.append(f"- **{reason}**: {duration} minutes")
                        elif isinstance(delays, dict):
                            for key, value in delays.items():
                                summary_parts.append(f"- **{key}**: {value}")
                    
                    formatted_summary = "\n".join(summary_parts)
                    
                    yield sse_event({
                        "type": "TEXT_MESSAGE_CONTENT",
                        "message": {
                            "id": f"msg-{uuid.uuid4().hex[:8]}",
                            "role": "assistant",
                            "content": formatted_summary
                        }
                    })
                else:
                    error_msg = tool_result.get('error', 'Unknown error') if isinstance(tool_result, dict) else str(tool_result)
                    yield sse_event({
                        "type": "TEXT_MESSAGE_CONTENT",
                        "message": {
                            "id": f"msg-{uuid.uuid4().hex[:8]}",
                            "role": "assistant", 
                            "content": f"âŒ Error fetching delay summary: {error_msg}"
                        }
                    })
                    
            except Exception as e:
                print(f"ğŸ¯ âŒ EXCEPTION IN ROUTE SELECTION: {e}")
                yield sse_event({
                    "type": "TEXT_MESSAGE_CONTENT", 
                    "message": {
                        "id": f"msg-{uuid.uuid4().hex[:8]}",
                        "role": "assistant",
                        "content": f"âŒ Error processing route selection: {str(e)}"
                    }
                })
            
            yield sse_event({"type": "STATE_UPDATE", "state": {"phase": "finished", "progress_pct": 100}})
            yield sse_event({"type": "RUN_FINISHED", "run_id": run_id})
            return

        # --- CASE 2: New Query (Normal Flow)
        if not user_query.strip():
            raise HTTPException(status_code=400, detail="No user query found")

        # THINKING: Initial analysis
        yield sse_event({
            "type": "STATE_UPDATE", 
            "state": {
                "phase": "thinking", 
                "progress_pct": 5,
                "message": "ğŸ§  Analyzing your flight query..."
            }
        })

        # ensure MCP
        try:
            await ensure_mcp_connected()
        except Exception as e:
            yield sse_event({"type": "RUN_ERROR", "error": f"MCP connect failed: {e}"})
            return

        loop = asyncio.get_event_loop()

        # --- PLAN (THINKING phase)
        yield sse_event({
            "type": "STATE_UPDATE", 
            "state": {
                "phase": "thinking", 
                "progress_pct": 15,
                "message": "ğŸ“‹ Planning which flight data tools to use..."
            }
        })
        
        try:
            plan_data = await loop.run_in_executor(None, mcp_client.plan_tools, user_query)
        except Exception as e:
            yield sse_event({"type": "RUN_ERROR", "error": f"Planner error: {e}"})
            return

        plan = plan_data.get("plan", []) if isinstance(plan_data, dict) else []
        planning_usage = plan_data.get("llm_usage", {})
        
        print(f"ğŸ¯ ğŸ“‹ GENERATED PLAN: {plan}")
        
        # DEBUG: Send token usage for planning
        print(f"DEBUG: Planning token usage: {planning_usage}")
        if planning_usage:
            yield sse_event({
                "type": "TOKEN_USAGE",
                "phase": "planning",
                "usage": planning_usage
            })
        
        yield sse_event({"type": "STATE_SNAPSHOT", "snapshot": {"plan": plan}})

        if not plan:
            yield sse_event({
                "type": "TEXT_MESSAGE_CONTENT", 
                "message": {
                    "id": f"msg-{uuid.uuid4().hex[:8]}",
                    "role": "assistant",
                    "content": "I couldn't generate a valid plan for your query. Please try rephrasing."
                }
            })
            yield sse_event({"type": "STATE_UPDATE", "state": {"phase": "finished", "progress_pct": 100}})
            yield sse_event({"type": "RUN_FINISHED", "run_id": run_id})
            return

        # --- PROCESSING: Tool execution
        yield sse_event({
            "type": "STATE_UPDATE", 
            "state": {
                "phase": "processing", 
                "progress_pct": 20,
                "message": f"ğŸ› ï¸ Executing {len(plan)} flight data tools..."
            }
        })

        results = []
        num_steps = max(1, len(plan))
        per_step = 60.0 / num_steps
        current_progress = 20.0

        for step_index, step in enumerate(plan):
            if await request.is_disconnected():
                return

            tool_name = step.get("tool")
            args = step.get("arguments", {}) or {}

            print(f"ğŸ¯ ğŸ”§ EXECUTING TOOL: {tool_name} with args: {args}")

            yield sse_event({
                "type": "STATE_UPDATE", 
                "state": {
                    "phase": "processing",
                    "progress_pct": round(current_progress),
                    "message": f"ğŸ”§ Running {tool_name}..."
                }
            })

            tool_call_id = f"toolcall-{uuid.uuid4().hex[:8]}"
            
            yield sse_event({
                "type": "TOOL_CALL_START",
                "toolCallId": tool_call_id,
                "toolCallName": tool_name,
                "parentMessageId": None
            })

            yield sse_event({
                "type": "TOOL_CALL_ARGS",
                "toolCallId": tool_call_id,
                "delta": json.dumps(args, ensure_ascii=False)
            })
            yield sse_event({"type": "TOOL_CALL_END", "toolCallId": tool_call_id})

            try:
                tool_result = await mcp_client.invoke_tool(tool_name, args)
                
                # ğŸ¯ DEBUG CODE 2: TOOL EXECUTION RESULT
                print("ğŸ¯ DEBUG 2: TOOL EXECUTION RESULT")
                print(f"ğŸ¯ Tool Name: {tool_name}")
                print(f"ğŸ¯ Tool Args: {args}")
                print(f"ğŸ¯ Tool Result Type: {type(tool_result)}")
                if isinstance(tool_result, dict):
                    print(f"ğŸ¯ Tool Result Keys: {tool_result.keys()}")
                    print(f"ğŸ¯ Tool Result OK: {tool_result.get('ok')}")
                    if tool_result.get('data'):
                        print(f"ğŸ¯ Tool Data Keys: {tool_result['data'].keys()}")
                        print(f"ğŸ¯ Tool Data Status: {tool_result['data'].get('status')}")
                
                # Check if multiple routes are available (for delay summary)
                if (tool_name == "get_delay_summary" and 
                    isinstance(tool_result, dict) and 
                    tool_result.get("ok")):
                    
                    data = tool_result.get("data", {})
                    print(f"ğŸ¯ Checking for route selection requirement...")
                    print(f"ğŸ¯ Data status: {data.get('status')}")
                    
                    if data.get("status") == "route_selection_required":
                        print("ğŸ¯ âœ… ROUTE SELECTION REQUIRED - Storing context...")
                        
                        # Store context for route selection
                        route_selection_context[thread_id] = {
                            "available_routes": data["available_routes"],
                            "original_args": args
                        }
                        
                        print(f"ğŸ¯ âœ… CONTEXT STORED for thread: {thread_id}")
                        print(f"ğŸ¯ Available routes count: {len(data['available_routes'])}")
                        print(f"ğŸ¯ Now route_selection_context has keys: {list(route_selection_context.keys())}")
                        
                        # Format route options for display
                        route_options = []
                        for idx, route in enumerate(data["available_routes"]):
                            route_options.append(
                                f"**{idx+1}. {route['startStation']} â†’ {route['endStation']}**\n"
                                f"   - Time: {route.get('scheduledStartTime', 'Unknown')}\n"
                                f"   - Status: {route['flightStatus']}"
                            )
                        
                        route_message = "\n\n".join(route_options)
                        
                        yield sse_event({
                            "type": "TEXT_MESSAGE_CONTENT",
                            "message": {
                                "id": f"msg-{uuid.uuid4().hex[:8]}",
                                "role": "assistant",
                                "content": f"**ğŸ›« Multiple Routes Found!**\n\n"
                                          f"{route_message}\n\n"
                                          f"**Please select a route by entering the number (1-{len(data['available_routes']}):**"
                            }
                        })
                        
                        # Stop further processing - wait for user route selection
                        yield sse_event({"type": "STATE_UPDATE", "state": {"phase": "finished", "progress_pct": 100}})
                        yield sse_event({"type": "RUN_FINISHED", "run_id": run_id})
                        return
                    else:
                        print("ğŸ¯ âŒ No route selection required or different status")
                else:
                    print("ğŸ¯ âŒ Not get_delay_summary or tool failed")
                # ğŸ¯ DEBUG CODE 2 ENDS HERE
                    
            except Exception as exc:
                tool_result = {"error": str(exc)}
                print(f"ğŸ¯ âŒ TOOL ERROR: {exc}")

            yield sse_event({
                "type": "TOOL_CALL_RESULT",
                "message": {
                    "id": f"msg-{uuid.uuid4().hex[:8]}",
                    "role": "tool",
                    "content": json.dumps(tool_result, ensure_ascii=False),
                    "tool_call_id": tool_call_id,
                }
            })
            results.append({tool_name: tool_result})

            yield sse_event({
                "type": "STEP_FINISHED",
                "step_index": step_index,
                "tool": tool_name
            })

            current_progress = min(80.0, 20.0 + per_step * (step_index + 1))
            
            if time.time() - last_heartbeat > 15:
                yield sse_event({"type": "HEARTBEAT", "ts": time.time()})
                last_heartbeat = time.time()

        # --- TYPING: Result generation
        yield sse_event({
            "type": "STATE_UPDATE", 
            "state": {
                "phase": "typing", 
                "progress_pct": 85,
                "message": "âœï¸ Generating your flight analysis..."
            }
        })

        try:
            summary_data = await loop.run_in_executor(None, mcp_client.summarize_results, user_query, plan, results)
            assistant_text = summary_data.get("summary", "") if isinstance(summary_data, dict) else str(summary_data)
            summarization_usage = summary_data.get("llm_usage", {})
            
            # DEBUG: Send token usage for summarization
            print(f"DEBUG: Summarization token usage: {summarization_usage}")
            if summarization_usage:
                yield sse_event({
                    "type": "TOKEN_USAGE",
                    "phase": "summarization", 
                    "usage": summarization_usage
                })
                
                # Calculate and send total token usage
                def safe_int(val):
                    return val if isinstance(val, int) else 0
                    
                total_usage = {
                    "prompt_tokens": safe_int(planning_usage.get('prompt_tokens', 0)) + safe_int(summarization_usage.get('prompt_tokens', 0)),
                    "completion_tokens": safe_int(planning_usage.get('completion_tokens', 0)) + safe_int(summarization_usage.get('completion_tokens', 0)),
                    "total_tokens": safe_int(planning_usage.get('total_tokens', 0)) + safe_int(summarization_usage.get('total_tokens', 0))
                }
                
                print(f"DEBUG: Total token usage: {total_usage}")
                yield sse_event({
                    "type": "TOKEN_USAGE",
                    "phase": "total",
                    "usage": total_usage
                })
                
        except Exception as e:
            assistant_text = f"âŒ Failed to summarize results: {e}"

        # Stream summary as chunks
        msg_id = f"msg-{uuid.uuid4().hex[:8]}"
        
        yield sse_event({
            "type": "TEXT_MESSAGE_CONTENT",
            "message": {
                "id": msg_id,
                "role": "assistant",
                "content": ""
            }
        })

        chunks = chunk_text(assistant_text, max_len=150)
        for i, chunk in enumerate(chunks):
            yield sse_event({
                "type": "TEXT_MESSAGE_CONTENT",
                "message": {
                    "id": msg_id,
                    "role": "assistant", 
                    "delta": chunk
                }
            })
            
            typing_progress = 85 + (i / len(chunks)) * 15
            yield sse_event({
                "type": "STATE_UPDATE",
                "state": {
                    "phase": "typing",
                    "progress_pct": round(typing_progress),
                    "message": "âœï¸ Generating your flight analysis..."
                }
            })
            
            await asyncio.sleep(0.03)

        # Final state
        yield sse_event({"type": "STATE_SNAPSHOT", "snapshot": {"plan": plan, "results": results}})
        yield sse_event({
            "type": "STATE_UPDATE", 
            "state": {
                "phase": "finished", 
                "progress_pct": 100,
                "message": "âœ… Analysis complete"
            }
        })
        yield sse_event({"type": "RUN_FINISHED", "run_id": run_id})

    return StreamingResponse(event_stream(), media_type="text/event-stream")
